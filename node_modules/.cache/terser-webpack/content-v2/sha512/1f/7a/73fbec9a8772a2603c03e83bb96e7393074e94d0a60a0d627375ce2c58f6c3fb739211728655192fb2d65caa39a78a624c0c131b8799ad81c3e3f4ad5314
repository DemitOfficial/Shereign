{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{MWin:function(module,__webpack_exports__,__webpack_require__){\"use strict\";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,\"MapsModule\",function(){return maps_module_MapsModule});var common=__webpack_require__(\"ofXK\"),tslib_es6=__webpack_require__(\"KhPJ\"),core=__webpack_require__(\"fXoL\"),Observable=__webpack_require__(\"HDdC\"),BehaviorSubject=__webpack_require__(\"2Vo4\"),from=__webpack_require__(\"Cfvw\"),timer=__webpack_require__(\"PqYM\"),isArray=(__webpack_require__(\"XNiG\"),__webpack_require__(\"DH7j\")),isFunction=__webpack_require__(\"n6bG\"),map=__webpack_require__(\"lJxs\");function fromEventPattern(addHandler,removeHandler,resultSelector){return resultSelector?fromEventPattern(addHandler,removeHandler).pipe(Object(map.a)(args=>Object(isArray.a)(args)?resultSelector(...args):resultSelector(args))):new Observable.a(subscriber=>{const handler=(...e)=>subscriber.next(1===e.length?e[0]:e);let retValue;try{retValue=addHandler(handler)}catch(err){return void subscriber.error(err)}if(Object(isFunction.a)(removeHandler))return()=>removeHandler(handler,retValue)})}var merge=__webpack_require__(\"VRyK\"),ReplaySubject=__webpack_require__(\"jtHE\");__webpack_require__(\"quSY\"),__webpack_require__(\"8Qeq\"),__webpack_require__(\"z+Ro\"),__webpack_require__(\"LRne\"),__webpack_require__(\"z6cu\");var mergeMap=__webpack_require__(\"5+tZ\"),innerSubscribe=__webpack_require__(\"zx2A\");class sample_SampleOperator{constructor(notifier){this.notifier=notifier}call(subscriber,source){const sampleSubscriber=new sample_SampleSubscriber(subscriber),subscription=source.subscribe(sampleSubscriber);return subscription.add(Object(innerSubscribe.c)(this.notifier,new innerSubscribe.a(sampleSubscriber))),subscription}}class sample_SampleSubscriber extends innerSubscribe.b{constructor(){super(...arguments),this.hasValue=!1}_next(value){this.value=value,this.hasValue=!0}notifyNext(){this.emitValue()}notifyComplete(){this.emitValue()}emitValue(){this.hasValue&&(this.hasValue=!1,this.destination.next(this.value))}}var switchMap=__webpack_require__(\"eIep\"),shareReplay=__webpack_require__(\"UXun\"),startWith=(__webpack_require__(\"/uUt\"),__webpack_require__(\"1G5W\"),__webpack_require__(\"JX91\")),skip=__webpack_require__(\"zP0r\");__webpack_require__(\"oB13\");const _c0=[\"*\"];let agm_core_MapsAPILoader=(()=>{let MapsAPILoader=class{};return MapsAPILoader.ɵfac=function(t){return new(t||MapsAPILoader)},MapsAPILoader.ɵprov=core.Mb({token:MapsAPILoader,factory:function(t){return MapsAPILoader.ɵfac(t)}}),MapsAPILoader})(),agm_core_GoogleMapsAPIWrapper=(()=>{let GoogleMapsAPIWrapper=class{constructor(_loader,_zone){this._loader=_loader,this._zone=_zone,this._map=new Promise(resolve=>{this._mapResolver=resolve})}createMap(el,mapOptions){return this._zone.runOutsideAngular(()=>this._loader.load().then(()=>{const map=new google.maps.Map(el,mapOptions);this._mapResolver(map)}))}setMapOptions(options){return this._zone.runOutsideAngular(()=>{this._map.then(m=>{m.setOptions(options)})})}createMarker(options={},addToMap=!0){return this._zone.runOutsideAngular(()=>this._map.then(map=>(addToMap&&(options.map=map),new google.maps.Marker(options))))}createInfoWindow(options){return this._zone.runOutsideAngular(()=>this._map.then(()=>new google.maps.InfoWindow(options)))}createCircle(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>(\"string\"==typeof options.strokePosition&&(options.strokePosition=google.maps.StrokePosition[options.strokePosition]),options.map=map,new google.maps.Circle(options))))}createRectangle(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>(options.map=map,new google.maps.Rectangle(options))))}createPolyline(options){return this._zone.runOutsideAngular(()=>this.getNativeMap().then(map=>{let line=new google.maps.Polyline(options);return line.setMap(map),line}))}createPolygon(options){return this._zone.runOutsideAngular(()=>this.getNativeMap().then(map=>{let polygon=new google.maps.Polygon(options);return polygon.setMap(map),polygon}))}createDataLayer(options){return this._zone.runOutsideAngular(()=>this._map.then(m=>{let data=new google.maps.Data(options);return data.setMap(m),data}))}createTransitLayer(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>{let newLayer=new google.maps.TransitLayer;return newLayer.setMap(options.visible?map:null),newLayer}))}createBicyclingLayer(options){return this._zone.runOutsideAngular(()=>this._map.then(map=>{let newLayer=new google.maps.BicyclingLayer;return newLayer.setMap(options.visible?map:null),newLayer}))}containsLocation(latLng,polygon){return google.maps.geometry.poly.containsLocation(latLng,polygon)}subscribeToMapEvent(eventName){return new Observable.a(observer=>{this._map.then(m=>{m.addListener(eventName,arg=>{this._zone.run(()=>observer.next(arg))})})})}clearInstanceListeners(){return this._zone.runOutsideAngular(()=>{this._map.then(map=>{google.maps.event.clearInstanceListeners(map)})})}setCenter(latLng){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.setCenter(latLng)))}getZoom(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getZoom()))}getBounds(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getBounds()))}getMapTypeId(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getMapTypeId()))}setZoom(zoom){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.setZoom(zoom)))}getCenter(){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.getCenter()))}panTo(latLng){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panTo(latLng)))}panBy(x,y){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panBy(x,y)))}fitBounds(latLng,padding){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.fitBounds(latLng,padding)))}panToBounds(latLng,padding){return this._zone.runOutsideAngular(()=>this._map.then(map=>map.panToBounds(latLng,padding)))}getNativeMap(){return this._map}triggerMapEvent(eventName){return this._map.then(m=>google.maps.event.trigger(m,eventName))}};return GoogleMapsAPIWrapper.ɵfac=function(t){return new(t||GoogleMapsAPIWrapper)(core.dc(agm_core_MapsAPILoader),core.dc(core.z))},GoogleMapsAPIWrapper.ɵprov=core.Mb({token:GoogleMapsAPIWrapper,factory:function(t){return GoogleMapsAPIWrapper.ɵfac(t)}}),GoogleMapsAPIWrapper=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_MapsAPILoader,core.z])],GoogleMapsAPIWrapper),GoogleMapsAPIWrapper})(),agm_core_LayerManager=(()=>{let LayerManager=class{constructor(_wrapper){this._wrapper=_wrapper,this._layers=new Map}addTransitLayer(layer,options){const newLayer=this._wrapper.createTransitLayer(options);this._layers.set(layer,newLayer)}addBicyclingLayer(layer,options){const newLayer=this._wrapper.createBicyclingLayer(options);this._layers.set(layer,newLayer)}deleteLayer(layer){return this._layers.get(layer).then(currentLayer=>{currentLayer.setMap(null),this._layers.delete(layer)})}toggleLayerVisibility(layer,options){return this._layers.get(layer).then(currentLayer=>options.visible?this._wrapper.getNativeMap().then(map=>{currentLayer.setMap(map)}):void currentLayer.setMap(null))}};return LayerManager.ɵfac=function(t){return new(t||LayerManager)(core.dc(agm_core_GoogleMapsAPIWrapper))},LayerManager.ɵprov=core.Mb({token:LayerManager,factory:function(t){return LayerManager.ɵfac(t)}}),LayerManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper])],LayerManager),LayerManager})(),agm_core_CircleManager=(()=>{let CircleManager=class{constructor(_apiWrapper,_zone){this._apiWrapper=_apiWrapper,this._zone=_zone,this._circles=new Map}addCircle(circle){this._circles.set(circle,this._apiWrapper.createCircle({center:{lat:circle.latitude,lng:circle.longitude},clickable:circle.clickable,draggable:circle.draggable,editable:circle.editable,fillColor:circle.fillColor,fillOpacity:circle.fillOpacity,radius:circle.radius,strokeColor:circle.strokeColor,strokeOpacity:circle.strokeOpacity,strokePosition:circle.strokePosition,strokeWeight:circle.strokeWeight,visible:circle.visible,zIndex:circle.zIndex}))}removeCircle(circle){return this._circles.get(circle).then(c=>{c.setMap(null),this._circles.delete(circle)})}setOptions(circle,options){return this._circles.get(circle).then(c=>{\"string\"==typeof options.strokePosition&&(options.strokePosition=google.maps.StrokePosition[options.strokePosition]),c.setOptions(options)})}getBounds(circle){return this._circles.get(circle).then(c=>c.getBounds())}getCenter(circle){return this._circles.get(circle).then(c=>c.getCenter())}getRadius(circle){return this._circles.get(circle).then(c=>c.getRadius())}setCenter(circle){return this._circles.get(circle).then(c=>c.setCenter({lat:circle.latitude,lng:circle.longitude}))}setEditable(circle){return this._circles.get(circle).then(c=>c.setEditable(circle.editable))}setDraggable(circle){return this._circles.get(circle).then(c=>c.setDraggable(circle.draggable))}setVisible(circle){return this._circles.get(circle).then(c=>c.setVisible(circle.visible))}setRadius(circle){return this._circles.get(circle).then(c=>c.setRadius(circle.radius))}getNativeCircle(circle){return this._circles.get(circle)}createEventObservable(eventName,circle){return new Observable.a(observer=>{let listener=null;return this._circles.get(circle).then(c=>{listener=c.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))}),()=>{null!==listener&&listener.remove()}})}};return CircleManager.ɵfac=function(t){return new(t||CircleManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},CircleManager.ɵprov=core.Mb({token:CircleManager,factory:function(t){return CircleManager.ɵfac(t)}}),CircleManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],CircleManager),CircleManager})();var AgmCircle_1;let agm_core_AgmCircle=(()=>{let AgmCircle=AgmCircle_1=class{constructor(_manager){this._manager=_manager,this.clickable=!0,this.draggable=!1,this.editable=!1,this.radius=0,this.strokePosition=\"CENTER\",this.strokeWeight=0,this.visible=!0,this.centerChange=new core.n,this.circleClick=new core.n,this.circleDblClick=new core.n,this.drag=new core.n,this.dragEnd=new core.n,this.dragStart=new core.n,this.mouseDown=new core.n,this.mouseMove=new core.n,this.mouseOut=new core.n,this.mouseOver=new core.n,this.mouseUp=new core.n,this.radiusChange=new core.n,this.rightClick=new core.n,this._circleAddedToManager=!1,this._eventSubscriptions=[]}ngOnInit(){this._manager.addCircle(this),this._circleAddedToManager=!0,this._registerEventListeners()}ngOnChanges(changes){this._circleAddedToManager&&((changes.latitude||changes.longitude)&&this._manager.setCenter(this),changes.editable&&this._manager.setEditable(this),changes.draggable&&this._manager.setDraggable(this),changes.visible&&this._manager.setVisible(this),changes.radius&&this._manager.setRadius(this),this._updateCircleOptionsChanges(changes))}_updateCircleOptionsChanges(changes){let options={},optionKeys=Object.keys(changes).filter(k=>-1!==AgmCircle_1._mapOptions.indexOf(k));optionKeys.forEach(k=>{options[k]=changes[k].currentValue}),optionKeys.length>0&&this._manager.setOptions(this,options)}_registerEventListeners(){let events=new Map;events.set(\"center_changed\",this.centerChange),events.set(\"click\",this.circleClick),events.set(\"dblclick\",this.circleDblClick),events.set(\"drag\",this.drag),events.set(\"dragend\",this.dragEnd),events.set(\"dragstart\",this.dragStart),events.set(\"mousedown\",this.mouseDown),events.set(\"mousemove\",this.mouseMove),events.set(\"mouseout\",this.mouseOut),events.set(\"mouseover\",this.mouseOver),events.set(\"mouseup\",this.mouseUp),events.set(\"radius_changed\",this.radiusChange),events.set(\"rightclick\",this.rightClick),events.forEach((eventEmitter,eventName)=>{this._eventSubscriptions.push(this._manager.createEventObservable(eventName,this).subscribe(value=>{switch(eventName){case\"radius_changed\":this._manager.getRadius(this).then(radius=>eventEmitter.emit(radius));break;case\"center_changed\":this._manager.getCenter(this).then(center=>eventEmitter.emit({lat:center.lat(),lng:center.lng()}));break;default:eventEmitter.emit({coords:{lat:value.latLng.lat(),lng:value.latLng.lng()}})}}))})}ngOnDestroy(){this._eventSubscriptions.forEach(function(s){s.unsubscribe()}),this._eventSubscriptions=null,this._manager.removeCircle(this)}getBounds(){return this._manager.getBounds(this)}getCenter(){return this._manager.getCenter(this)}};return AgmCircle.ɵfac=function(t){return new(t||AgmCircle)(core.Qb(agm_core_CircleManager))},AgmCircle.ɵdir=core.Lb({type:AgmCircle,selectors:[[\"agm-circle\"]],inputs:{clickable:\"clickable\",draggable:[\"circleDraggable\",\"draggable\"],editable:\"editable\",radius:\"radius\",strokePosition:\"strokePosition\",strokeWeight:\"strokeWeight\",visible:\"visible\",latitude:\"latitude\",longitude:\"longitude\",fillColor:\"fillColor\",fillOpacity:\"fillOpacity\",strokeColor:\"strokeColor\",strokeOpacity:\"strokeOpacity\",zIndex:\"zIndex\"},outputs:{centerChange:\"centerChange\",circleClick:\"circleClick\",circleDblClick:\"circleDblClick\",drag:\"drag\",dragEnd:\"dragEnd\",dragStart:\"dragStart\",mouseDown:\"mouseDown\",mouseMove:\"mouseMove\",mouseOut:\"mouseOut\",mouseOver:\"mouseOver\",mouseUp:\"mouseUp\",radiusChange:\"radiusChange\",rightClick:\"rightClick\"},features:[core.Ab]}),AgmCircle._mapOptions=[\"fillColor\",\"fillOpacity\",\"strokeColor\",\"strokeOpacity\",\"strokePosition\",\"strokeWeight\",\"visible\",\"zIndex\",\"clickable\"],AgmCircle=AgmCircle_1=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_CircleManager])],AgmCircle),AgmCircle})(),agm_core_DataLayerManager=(()=>{let DataLayerManager=class{constructor(_wrapper,_zone){this._wrapper=_wrapper,this._zone=_zone,this._layers=new Map}addDataLayer(layer){const newLayer=this._wrapper.createDataLayer({style:layer.style}).then(d=>(layer.geoJson&&this.getDataFeatures(d,layer.geoJson).then(features=>d.features=features),d));this._layers.set(layer,newLayer)}deleteDataLayer(layer){this._layers.get(layer).then(l=>{l.setMap(null),this._layers.delete(layer)})}updateGeoJson(layer,geoJson){this._layers.get(layer).then(l=>{l.forEach(function(feature){l.remove(feature);var index=l.features.indexOf(feature,0);index>-1&&l.features.splice(index,1)}),this.getDataFeatures(l,geoJson).then(features=>l.features=features)})}setDataOptions(layer,options){this._layers.get(layer).then(l=>{l.setControlPosition(options.controlPosition),l.setControls(options.controls),l.setDrawingMode(options.drawingMode),l.setStyle(options.style)})}createEventObservable(eventName,layer){return new Observable.a(observer=>{this._layers.get(layer).then(d=>{d.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}getDataFeatures(d,geoJson){return new Promise((resolve,reject)=>{if(\"object\"==typeof geoJson)try{resolve(d.addGeoJson(geoJson))}catch(e){reject(e)}else\"string\"==typeof geoJson?d.loadGeoJson(geoJson,null,resolve):reject(\"Impossible to extract features from geoJson: wrong argument type\")})}};return DataLayerManager.ɵfac=function(t){return new(t||DataLayerManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},DataLayerManager.ɵprov=core.Mb({token:DataLayerManager,factory:function(t){return DataLayerManager.ɵfac(t)}}),DataLayerManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],DataLayerManager),DataLayerManager})();class FitBoundsAccessor{}let agm_core_FitBoundsService=(()=>{let FitBoundsService=class{constructor(loader){var notifier;this._boundsChangeSampleTime$=new BehaviorSubject.a(200),this._includeInBounds$=new BehaviorSubject.a(new Map),this.bounds$=Object(from.a)(loader.load()).pipe(Object(mergeMap.a)(()=>this._includeInBounds$),(notifier=this._boundsChangeSampleTime$.pipe(Object(switchMap.a)(time=>Object(timer.a)(0,time))),source=>source.lift(new sample_SampleOperator(notifier))),Object(map.a)(includeInBounds=>this._generateBounds(includeInBounds)),Object(shareReplay.a)(1))}_generateBounds(includeInBounds){const bounds=new google.maps.LatLngBounds;return includeInBounds.forEach(b=>bounds.extend(b)),bounds}addToBounds(latLng){const id=this._createIdentifier(latLng);if(this._includeInBounds$.value.has(id))return;const map=this._includeInBounds$.value;map.set(id,latLng),this._includeInBounds$.next(map)}removeFromBounds(latLng){const map=this._includeInBounds$.value;map.delete(this._createIdentifier(latLng)),this._includeInBounds$.next(map)}changeFitBoundsChangeSampleTime(timeMs){this._boundsChangeSampleTime$.next(timeMs)}getBounds$(){return this.bounds$}_createIdentifier(latLng){return`${latLng.lat}+${latLng.lng}`}};return FitBoundsService.ɵfac=function(t){return new(t||FitBoundsService)(core.dc(agm_core_MapsAPILoader))},FitBoundsService.ɵprov=core.Mb({token:FitBoundsService,factory:function(t){return FitBoundsService.ɵfac(t)}}),FitBoundsService=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_MapsAPILoader])],FitBoundsService),FitBoundsService})(),agm_core_MarkerManager=(()=>{let MarkerManager=class{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._markers=new Map}convertAnimation(uiAnim){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){return null===uiAnim?null:this._mapsWrapper.getNativeMap().then(()=>google.maps.Animation[uiAnim])})}deleteMarker(marker){const m=this._markers.get(marker);return null==m?Promise.resolve():m.then(m=>this._zone.run(()=>{m.setMap(null),this._markers.delete(marker)}))}updateMarkerPosition(marker){return this._markers.get(marker).then(m=>m.setPosition({lat:marker.latitude,lng:marker.longitude}))}updateTitle(marker){return this._markers.get(marker).then(m=>m.setTitle(marker.title))}updateLabel(marker){return this._markers.get(marker).then(m=>{m.setLabel(marker.label)})}updateDraggable(marker){return this._markers.get(marker).then(m=>m.setDraggable(marker.draggable))}updateIcon(marker){return this._markers.get(marker).then(m=>m.setIcon(marker.iconUrl))}updateOpacity(marker){return this._markers.get(marker).then(m=>m.setOpacity(marker.opacity))}updateVisible(marker){return this._markers.get(marker).then(m=>m.setVisible(marker.visible))}updateZIndex(marker){return this._markers.get(marker).then(m=>m.setZIndex(marker.zIndex))}updateClickable(marker){return this._markers.get(marker).then(m=>m.setClickable(marker.clickable))}updateAnimation(marker){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){(yield this._markers.get(marker)).setAnimation(yield this.convertAnimation(marker.animation))})}addMarker(marker){const markerPromise=new Promise(resolve=>Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){return this._mapsWrapper.createMarker({position:{lat:marker.latitude,lng:marker.longitude},label:marker.label,draggable:marker.draggable,icon:marker.iconUrl,opacity:marker.opacity,visible:marker.visible,zIndex:marker.zIndex,title:marker.title,clickable:marker.clickable,animation:yield this.convertAnimation(marker.animation)}).then(resolve)}));this._markers.set(marker,markerPromise)}getNativeMarker(marker){return this._markers.get(marker)}createEventObservable(eventName,marker){return new Observable.a(observer=>{this._markers.get(marker).then(m=>{m.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}};return MarkerManager.ɵfac=function(t){return new(t||MarkerManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},MarkerManager.ɵprov=core.Mb({token:MarkerManager,factory:function(t){return MarkerManager.ɵfac(t)}}),MarkerManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],MarkerManager),MarkerManager})(),agm_core_InfoWindowManager=(()=>{let InfoWindowManager=class{constructor(_mapsWrapper,_zone,_markerManager){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._markerManager=_markerManager,this._infoWindows=new Map}deleteInfoWindow(infoWindow){const iWindow=this._infoWindows.get(infoWindow);return null==iWindow?Promise.resolve():iWindow.then(i=>this._zone.run(()=>{i.close(),this._infoWindows.delete(infoWindow)}))}setPosition(infoWindow){return this._infoWindows.get(infoWindow).then(i=>i.setPosition({lat:infoWindow.latitude,lng:infoWindow.longitude}))}setZIndex(infoWindow){return this._infoWindows.get(infoWindow).then(i=>i.setZIndex(infoWindow.zIndex))}open(infoWindow){return this._infoWindows.get(infoWindow).then(w=>null!=infoWindow.hostMarker?this._markerManager.getNativeMarker(infoWindow.hostMarker).then(marker=>this._mapsWrapper.getNativeMap().then(map=>w.open(map,marker))):this._mapsWrapper.getNativeMap().then(map=>w.open(map)))}close(infoWindow){return this._infoWindows.get(infoWindow).then(w=>w.close())}setOptions(infoWindow,options){return this._infoWindows.get(infoWindow).then(i=>i.setOptions(options))}addInfoWindow(infoWindow){const options={content:infoWindow.content,maxWidth:infoWindow.maxWidth,zIndex:infoWindow.zIndex,disableAutoPan:infoWindow.disableAutoPan};\"number\"==typeof infoWindow.latitude&&\"number\"==typeof infoWindow.longitude&&(options.position={lat:infoWindow.latitude,lng:infoWindow.longitude});const infoWindowPromise=this._mapsWrapper.createInfoWindow(options);this._infoWindows.set(infoWindow,infoWindowPromise)}createEventObservable(eventName,infoWindow){return new Observable.a(observer=>{this._infoWindows.get(infoWindow).then(i=>{i.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}};return InfoWindowManager.ɵfac=function(t){return new(t||InfoWindowManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z),core.dc(agm_core_MarkerManager))},InfoWindowManager.ɵprov=core.Mb({token:InfoWindowManager,factory:function(t){return InfoWindowManager.ɵfac(t)}}),InfoWindowManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z,agm_core_MarkerManager])],InfoWindowManager),InfoWindowManager})();var AgmInfoWindow_1;let infoWindowId=0,agm_core_AgmInfoWindow=(()=>{let AgmInfoWindow=AgmInfoWindow_1=class{constructor(_infoWindowManager,_el){this._infoWindowManager=_infoWindowManager,this._el=_el,this.isOpen=!1,this.infoWindowClose=new core.n,this._infoWindowAddedToManager=!1,this._id=(infoWindowId++).toString()}ngOnInit(){this.content=this._el.nativeElement.querySelector(\".agm-info-window-content\"),this._infoWindowManager.addInfoWindow(this),this._infoWindowAddedToManager=!0,this._updateOpenState(),this._registerEventListeners()}ngOnChanges(changes){this._infoWindowAddedToManager&&((changes.latitude||changes.longitude)&&\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude&&this._infoWindowManager.setPosition(this),changes.zIndex&&this._infoWindowManager.setZIndex(this),changes.isOpen&&this._updateOpenState(),this._setInfoWindowOptions(changes))}_registerEventListeners(){this._infoWindowManager.createEventObservable(\"closeclick\",this).subscribe(()=>{this.isOpen=!1,this.infoWindowClose.emit()})}_updateOpenState(){this.isOpen?this.open():this.close()}_setInfoWindowOptions(changes){let options={};Object.keys(changes).filter(k=>-1!==AgmInfoWindow_1._infoWindowOptionsInputs.indexOf(k)).forEach(k=>{options[k]=changes[k].currentValue}),this._infoWindowManager.setOptions(this,options)}open(){return this._infoWindowManager.open(this)}close(){return this._infoWindowManager.close(this).then(()=>{this.infoWindowClose.emit()})}id(){return this._id}toString(){return\"AgmInfoWindow-\"+this._id.toString()}ngOnDestroy(){this._infoWindowManager.deleteInfoWindow(this)}};return AgmInfoWindow.ɵfac=function(t){return new(t||AgmInfoWindow)(core.Qb(agm_core_InfoWindowManager),core.Qb(core.l))},AgmInfoWindow.ɵcmp=core.Kb({type:AgmInfoWindow,selectors:[[\"agm-info-window\"]],inputs:{isOpen:\"isOpen\",latitude:\"latitude\",longitude:\"longitude\",disableAutoPan:\"disableAutoPan\",zIndex:\"zIndex\",maxWidth:\"maxWidth\"},outputs:{infoWindowClose:\"infoWindowClose\"},features:[core.Ab],ngContentSelectors:_c0,decls:2,vars:0,consts:[[1,\"agm-info-window-content\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Wb(0,\"div\",0),core.nc(1),core.Vb())},encapsulation:2}),AgmInfoWindow._infoWindowOptionsInputs=[\"disableAutoPan\",\"maxWidth\"],AgmInfoWindow=AgmInfoWindow_1=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_InfoWindowManager,core.l])],AgmInfoWindow),AgmInfoWindow})(),agm_core_KmlLayerManager=(()=>{let KmlLayerManager=class{constructor(_wrapper,_zone){this._wrapper=_wrapper,this._zone=_zone,this._layers=new Map}addKmlLayer(layer){const newLayer=this._wrapper.getNativeMap().then(m=>new google.maps.KmlLayer({clickable:layer.clickable,map:m,preserveViewport:layer.preserveViewport,screenOverlays:layer.screenOverlays,suppressInfoWindows:layer.suppressInfoWindows,url:layer.url,zIndex:layer.zIndex}));this._layers.set(layer,newLayer)}setOptions(layer,options){this._layers.get(layer).then(l=>l.setOptions(options))}deleteKmlLayer(layer){this._layers.get(layer).then(l=>{l.setMap(null),this._layers.delete(layer)})}createEventObservable(eventName,layer){return new Observable.a(observer=>{this._layers.get(layer).then(m=>{m.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}};return KmlLayerManager.ɵfac=function(t){return new(t||KmlLayerManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},KmlLayerManager.ɵprov=core.Mb({token:KmlLayerManager,factory:function(t){return KmlLayerManager.ɵfac(t)}}),KmlLayerManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],KmlLayerManager),KmlLayerManager})();function createMVCEventObservable(array){const eventNames=[\"insert_at\",\"remove_at\",\"set_at\"];return fromEventPattern(handler=>eventNames.map(evName=>array.addListener(evName,(index,previous)=>handler.apply(array,[{newArr:array.getArray(),evName:evName,index:index,previous:previous}]))),(_handler,evListeners)=>evListeners.forEach(evListener=>evListener.remove()))}let agm_core_PolygonManager=(()=>{let PolygonManager=class{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._polygons=new Map}addPolygon(path){const polygonPromise=this._mapsWrapper.createPolygon({clickable:path.clickable,draggable:path.draggable,editable:path.editable,fillColor:path.fillColor,fillOpacity:path.fillOpacity,geodesic:path.geodesic,paths:path.paths,strokeColor:path.strokeColor,strokeOpacity:path.strokeOpacity,strokeWeight:path.strokeWeight,visible:path.visible,zIndex:path.zIndex});this._polygons.set(path,polygonPromise)}updatePolygon(polygon){const m=this._polygons.get(polygon);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setPaths(polygon.paths)}))}setPolygonOptions(path,options){return this._polygons.get(path).then(l=>{l.setOptions(options)})}deletePolygon(paths){const m=this._polygons.get(paths);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setMap(null),this._polygons.delete(paths)}))}getPath(polygon){return this._polygons.get(polygon).then(polygon=>polygon.getPath().getArray())}getPaths(polygon){return this._polygons.get(polygon).then(polygon=>polygon.getPaths().getArray().map(p=>p.getArray()))}createEventObservable(eventName,path){return new Observable.a(observer=>{this._polygons.get(path).then(l=>{l.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}createPathEventObservable(agmPolygon){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){const paths=(yield this._polygons.get(agmPolygon)).getPaths();return createMVCEventObservable(paths).pipe(Object(startWith.a)({newArr:paths.getArray()}),Object(switchMap.a)(parentMVEvent=>Object(merge.a)(...parentMVEvent.newArr.map((chMVC,index)=>createMVCEventObservable(chMVC).pipe(Object(map.a)(chMVCEvent=>({parentMVEvent:parentMVEvent,chMVCEvent:chMVCEvent,pathIndex:index}))))).pipe(Object(startWith.a)({parentMVEvent:parentMVEvent,chMVCEvent:null,pathIndex:null}))),Object(skip.a)(1),Object(map.a)(({parentMVEvent:parentMVEvent,chMVCEvent:chMVCEvent,pathIndex:pathIndex})=>{let retVal;return chMVCEvent?(retVal={newArr:parentMVEvent.newArr.map(subArr=>subArr.getArray().map(latLng=>latLng.toJSON())),pathIndex:pathIndex,eventName:chMVCEvent.evName,index:chMVCEvent.index},chMVCEvent.previous&&(retVal.previous=chMVCEvent.previous)):(retVal={newArr:parentMVEvent.newArr.map(subArr=>subArr.getArray().map(latLng=>latLng.toJSON())),eventName:parentMVEvent.evName,index:parentMVEvent.index},parentMVEvent.previous&&(retVal.previous=parentMVEvent.previous.getArray())),retVal}))})}};return PolygonManager.ɵfac=function(t){return new(t||PolygonManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},PolygonManager.ɵprov=core.Mb({token:PolygonManager,factory:function(t){return PolygonManager.ɵfac(t)}}),PolygonManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],PolygonManager),PolygonManager})();var PolylineManager_1;let agm_core_PolylineManager=(()=>{let PolylineManager=PolylineManager_1=class{constructor(_mapsWrapper,_zone){this._mapsWrapper=_mapsWrapper,this._zone=_zone,this._polylines=new Map}static _convertPoints(line){return line._getPoints().map(point=>({lat:point.latitude,lng:point.longitude}))}static _convertPath(path){const symbolPath=google.maps.SymbolPath[path];return\"number\"==typeof symbolPath?symbolPath:path}static _convertIcons(line){const icons=line._getIcons().map(agmIcon=>({fixedRotation:agmIcon.fixedRotation,offset:agmIcon.offset,repeat:agmIcon.repeat,icon:{anchor:new google.maps.Point(agmIcon.anchorX,agmIcon.anchorY),fillColor:agmIcon.fillColor,fillOpacity:agmIcon.fillOpacity,path:PolylineManager_1._convertPath(agmIcon.path),rotation:agmIcon.rotation,scale:agmIcon.scale,strokeColor:agmIcon.strokeColor,strokeOpacity:agmIcon.strokeOpacity,strokeWeight:agmIcon.strokeWeight}}));return icons.forEach(icon=>{Object.entries(icon).forEach(([key,val])=>{void 0===val&&delete icon[key]}),void 0!==icon.icon.anchor.x&&void 0!==icon.icon.anchor.y||delete icon.icon.anchor}),icons}addPolyline(line){const polylinePromise=this._mapsWrapper.getNativeMap().then(()=>[PolylineManager_1._convertPoints(line),PolylineManager_1._convertIcons(line)]).then(([path,icons])=>this._mapsWrapper.createPolyline({clickable:line.clickable,draggable:line.draggable,editable:line.editable,geodesic:line.geodesic,strokeColor:line.strokeColor,strokeOpacity:line.strokeOpacity,strokeWeight:line.strokeWeight,visible:line.visible,zIndex:line.zIndex,path:path,icons:icons}));this._polylines.set(line,polylinePromise)}updatePolylinePoints(line){const path=PolylineManager_1._convertPoints(line),m=this._polylines.get(line);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setPath(path)}))}updateIconSequences(line){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){yield this._mapsWrapper.getNativeMap();const icons=PolylineManager_1._convertIcons(line),m=this._polylines.get(line);if(null!=m)return m.then(l=>this._zone.run(()=>l.setOptions({icons:icons})))})}setPolylineOptions(line,options){return this._polylines.get(line).then(l=>{l.setOptions(options)})}deletePolyline(line){const m=this._polylines.get(line);return null==m?Promise.resolve():m.then(l=>this._zone.run(()=>{l.setMap(null),this._polylines.delete(line)}))}getMVCPath(agmPolyline){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){return(yield this._polylines.get(agmPolyline)).getPath()})}getPath(agmPolyline){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){return(yield this.getMVCPath(agmPolyline)).getArray()})}createEventObservable(eventName,line){return new Observable.a(observer=>{this._polylines.get(line).then(l=>{l.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))})})}createPathEventObservable(line){return Object(tslib_es6.__awaiter)(this,void 0,void 0,function*(){return createMVCEventObservable(yield this.getMVCPath(line))})}};return PolylineManager.ɵfac=function(t){return new(t||PolylineManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},PolylineManager.ɵprov=core.Mb({token:PolylineManager,factory:function(t){return PolylineManager.ɵfac(t)}}),PolylineManager=PolylineManager_1=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],PolylineManager),PolylineManager})(),agm_core_RectangleManager=(()=>{let RectangleManager=class{constructor(_apiWrapper,_zone){this._apiWrapper=_apiWrapper,this._zone=_zone,this._rectangles=new Map}addRectangle(rectangle){this._rectangles.set(rectangle,this._apiWrapper.createRectangle({bounds:{north:rectangle.north,east:rectangle.east,south:rectangle.south,west:rectangle.west},clickable:rectangle.clickable,draggable:rectangle.draggable,editable:rectangle.editable,fillColor:rectangle.fillColor,fillOpacity:rectangle.fillOpacity,strokeColor:rectangle.strokeColor,strokeOpacity:rectangle.strokeOpacity,strokePosition:rectangle.strokePosition,strokeWeight:rectangle.strokeWeight,visible:rectangle.visible,zIndex:rectangle.zIndex}))}removeRectangle(rectangle){return this._rectangles.get(rectangle).then(r=>{r.setMap(null),this._rectangles.delete(rectangle)})}setOptions(rectangle,options){return this._rectangles.get(rectangle).then(r=>r.setOptions(options))}getBounds(rectangle){return this._rectangles.get(rectangle).then(r=>r.getBounds())}setBounds(rectangle){return this._rectangles.get(rectangle).then(r=>r.setBounds({north:rectangle.north,east:rectangle.east,south:rectangle.south,west:rectangle.west}))}setEditable(rectangle){return this._rectangles.get(rectangle).then(r=>r.setEditable(rectangle.editable))}setDraggable(rectangle){return this._rectangles.get(rectangle).then(r=>r.setDraggable(rectangle.draggable))}setVisible(rectangle){return this._rectangles.get(rectangle).then(r=>r.setVisible(rectangle.visible))}createEventObservable(eventName,rectangle){return Observable.a.create(observer=>{let listener=null;return this._rectangles.get(rectangle).then(r=>{listener=r.addListener(eventName,e=>this._zone.run(()=>observer.next(e)))}),()=>{null!==listener&&listener.remove()}})}};return RectangleManager.ɵfac=function(t){return new(t||RectangleManager)(core.dc(agm_core_GoogleMapsAPIWrapper),core.dc(core.z))},RectangleManager.ɵprov=core.Mb({token:RectangleManager,factory:function(t){return RectangleManager.ɵfac(t)}}),RectangleManager=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_GoogleMapsAPIWrapper,core.z])],RectangleManager),RectangleManager})();var AgmMap_1;let agm_core_AgmMap=(()=>{let AgmMap=AgmMap_1=class{constructor(_elem,_mapsWrapper,_platformId,_fitBoundsService,_zone){this._elem=_elem,this._mapsWrapper=_mapsWrapper,this._platformId=_platformId,this._fitBoundsService=_fitBoundsService,this._zone=_zone,this.longitude=0,this.latitude=0,this.zoom=8,this.draggable=!0,this.disableDoubleClickZoom=!1,this.disableDefaultUI=!1,this.scrollwheel=!0,this.keyboardShortcuts=!0,this.styles=[],this.usePanning=!1,this.fitBounds=!1,this.scaleControl=!1,this.mapTypeControl=!1,this.panControl=!1,this.rotateControl=!1,this.fullscreenControl=!1,this.mapTypeId=\"roadmap\",this.clickableIcons=!0,this.showDefaultInfoWindow=!0,this.gestureHandling=\"auto\",this.tilt=0,this._observableSubscriptions=[],this.mapClick=new core.n,this.mapRightClick=new core.n,this.mapDblClick=new core.n,this.centerChange=new core.n,this.boundsChange=new core.n,this.mapTypeIdChange=new core.n,this.idle=new core.n,this.zoomChange=new core.n,this.mapReady=new core.n,this.tilesLoaded=new core.n}ngOnInit(){if(Object(common.A)(this._platformId))return;const container=this._elem.nativeElement.querySelector(\".agm-map-container-inner\");this._initMapInstance(container)}_initMapInstance(el){this._mapsWrapper.createMap(el,{center:{lat:this.latitude||0,lng:this.longitude||0},zoom:this.zoom,minZoom:this.minZoom,maxZoom:this.maxZoom,controlSize:this.controlSize,disableDefaultUI:this.disableDefaultUI,disableDoubleClickZoom:this.disableDoubleClickZoom,scrollwheel:this.scrollwheel,backgroundColor:this.backgroundColor,draggable:this.draggable,draggableCursor:this.draggableCursor,draggingCursor:this.draggingCursor,keyboardShortcuts:this.keyboardShortcuts,styles:this.styles,zoomControl:this.zoomControl,zoomControlOptions:this.zoomControlOptions,streetViewControl:this.streetViewControl,streetViewControlOptions:this.streetViewControlOptions,scaleControl:this.scaleControl,scaleControlOptions:this.scaleControlOptions,mapTypeControl:this.mapTypeControl,mapTypeControlOptions:this.mapTypeControlOptions,panControl:this.panControl,panControlOptions:this.panControlOptions,rotateControl:this.rotateControl,rotateControlOptions:this.rotateControlOptions,fullscreenControl:this.fullscreenControl,fullscreenControlOptions:this.fullscreenControlOptions,mapTypeId:this.mapTypeId,clickableIcons:this.clickableIcons,gestureHandling:this.gestureHandling,tilt:this.tilt,restriction:this.restriction}).then(()=>this._mapsWrapper.getNativeMap()).then(map=>this.mapReady.emit(map)),this._handleMapCenterChange(),this._handleMapZoomChange(),this._handleMapMouseEvents(),this._handleBoundsChange(),this._handleMapTypeIdChange(),this._handleTilesLoadedEvent(),this._handleIdleEvent()}ngOnDestroy(){this._observableSubscriptions.forEach(s=>s.unsubscribe()),this._mapsWrapper.clearInstanceListeners(),this._fitBoundsSubscription&&this._fitBoundsSubscription.unsubscribe()}ngOnChanges(changes){this._updateMapOptionsChanges(changes),this._updatePosition(changes)}_updateMapOptionsChanges(changes){let options={};Object.keys(changes).filter(k=>-1!==AgmMap_1._mapOptionsAttributes.indexOf(k)).forEach(k=>{options[k]=changes[k].currentValue}),this._mapsWrapper.setMapOptions(options)}triggerResize(recenter=!0){return new Promise(resolve=>{setTimeout(()=>this._mapsWrapper.triggerMapEvent(\"resize\").then(()=>{recenter&&(null!=this.fitBounds?this._fitBounds():this._setCenter()),resolve()}))})}_updatePosition(changes){(null!=changes.latitude||null!=changes.longitude||changes.fitBounds)&&(\"fitBounds\"in changes?this._fitBounds():\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude&&this._setCenter())}_setCenter(){let newCenter={lat:this.latitude,lng:this.longitude};this.usePanning?this._mapsWrapper.panTo(newCenter):this._mapsWrapper.setCenter(newCenter)}_fitBounds(){switch(this.fitBounds){case!0:this._subscribeToFitBoundsUpdates();break;case!1:this._fitBoundsSubscription&&this._fitBoundsSubscription.unsubscribe();break;default:this._updateBounds(this.fitBounds,this.fitBoundsPadding)}}_subscribeToFitBoundsUpdates(){this._zone.runOutsideAngular(()=>{this._fitBoundsSubscription=this._fitBoundsService.getBounds$().subscribe(b=>{this._zone.run(()=>this._updateBounds(b,this.fitBoundsPadding))})})}_updateBounds(bounds,padding){if(bounds){if(this._isLatLngBoundsLiteral(bounds)&&\"undefined\"!=typeof google&&google&&google.maps&&google.maps.LatLngBounds){const newBounds=new google.maps.LatLngBounds;newBounds.union(bounds),bounds=newBounds}this.usePanning?this._mapsWrapper.panToBounds(bounds,padding):this._mapsWrapper.fitBounds(bounds,padding)}}_isLatLngBoundsLiteral(bounds){return null!=bounds&&void 0===bounds.extend}_handleMapCenterChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"center_changed\").subscribe(()=>{this._mapsWrapper.getCenter().then(center=>{this.latitude=center.lat(),this.longitude=center.lng(),this.centerChange.emit({lat:this.latitude,lng:this.longitude})})});this._observableSubscriptions.push(s)}_handleBoundsChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"bounds_changed\").subscribe(()=>{this._mapsWrapper.getBounds().then(bounds=>{this.boundsChange.emit(bounds)})});this._observableSubscriptions.push(s)}_handleMapTypeIdChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"maptypeid_changed\").subscribe(()=>{this._mapsWrapper.getMapTypeId().then(mapTypeId=>{this.mapTypeIdChange.emit(mapTypeId)})});this._observableSubscriptions.push(s)}_handleMapZoomChange(){const s=this._mapsWrapper.subscribeToMapEvent(\"zoom_changed\").subscribe(()=>{this._mapsWrapper.getZoom().then(z=>{this.zoom=z,this.zoomChange.emit(z)})});this._observableSubscriptions.push(s)}_handleIdleEvent(){const s=this._mapsWrapper.subscribeToMapEvent(\"idle\").subscribe(()=>{this.idle.emit(void 0)});this._observableSubscriptions.push(s)}_handleTilesLoadedEvent(){const s=this._mapsWrapper.subscribeToMapEvent(\"tilesloaded\").subscribe(()=>this.tilesLoaded.emit(void 0));this._observableSubscriptions.push(s)}_handleMapMouseEvents(){[{name:\"click\",emitter:this.mapClick},{name:\"rightclick\",emitter:this.mapRightClick},{name:\"dblclick\",emitter:this.mapDblClick}].forEach(e=>{const s=this._mapsWrapper.subscribeToMapEvent(e.name).subscribe(event=>{let value={coords:{lat:event.latLng.lat(),lng:event.latLng.lng()},placeId:event.placeId};value.placeId&&!this.showDefaultInfoWindow&&event.stop(),e.emitter.emit(value)});this._observableSubscriptions.push(s)})}};return AgmMap.ɵfac=function(t){return new(t||AgmMap)(core.Qb(core.l),core.Qb(agm_core_GoogleMapsAPIWrapper),core.Qb(core.B),core.Qb(agm_core_FitBoundsService),core.Qb(core.z))},AgmMap.ɵcmp=core.Kb({type:AgmMap,selectors:[[\"agm-map\"]],hostVars:2,hostBindings:function(rf,ctx){2&rf&&core.Ib(\"sebm-google-map-container\",!0)},inputs:{longitude:\"longitude\",latitude:\"latitude\",zoom:\"zoom\",draggable:[\"mapDraggable\",\"draggable\"],disableDoubleClickZoom:\"disableDoubleClickZoom\",disableDefaultUI:\"disableDefaultUI\",scrollwheel:\"scrollwheel\",keyboardShortcuts:\"keyboardShortcuts\",styles:\"styles\",usePanning:\"usePanning\",fitBounds:\"fitBounds\",scaleControl:\"scaleControl\",mapTypeControl:\"mapTypeControl\",panControl:\"panControl\",rotateControl:\"rotateControl\",fullscreenControl:\"fullscreenControl\",mapTypeId:\"mapTypeId\",clickableIcons:\"clickableIcons\",showDefaultInfoWindow:\"showDefaultInfoWindow\",gestureHandling:\"gestureHandling\",tilt:\"tilt\",minZoom:\"minZoom\",maxZoom:\"maxZoom\",controlSize:\"controlSize\",backgroundColor:\"backgroundColor\",draggableCursor:\"draggableCursor\",draggingCursor:\"draggingCursor\",zoomControl:\"zoomControl\",zoomControlOptions:\"zoomControlOptions\",streetViewControl:\"streetViewControl\",streetViewControlOptions:\"streetViewControlOptions\",fitBoundsPadding:\"fitBoundsPadding\",scaleControlOptions:\"scaleControlOptions\",mapTypeControlOptions:\"mapTypeControlOptions\",panControlOptions:\"panControlOptions\",rotateControlOptions:\"rotateControlOptions\",fullscreenControlOptions:\"fullscreenControlOptions\",restriction:\"restriction\"},outputs:{mapClick:\"mapClick\",mapRightClick:\"mapRightClick\",mapDblClick:\"mapDblClick\",centerChange:\"centerChange\",boundsChange:\"boundsChange\",mapTypeIdChange:\"mapTypeIdChange\",idle:\"idle\",zoomChange:\"zoomChange\",mapReady:\"mapReady\",tilesLoaded:\"tilesLoaded\"},features:[core.Bb([agm_core_CircleManager,agm_core_DataLayerManager,agm_core_DataLayerManager,agm_core_FitBoundsService,agm_core_GoogleMapsAPIWrapper,agm_core_InfoWindowManager,agm_core_KmlLayerManager,agm_core_LayerManager,agm_core_MarkerManager,agm_core_PolygonManager,agm_core_PolylineManager,agm_core_RectangleManager]),core.Ab],ngContentSelectors:_c0,decls:3,vars:0,consts:[[1,\"agm-map-container-inner\",\"sebm-google-map-container-inner\"],[1,\"agm-map-content\"]],template:function(rf,ctx){1&rf&&(core.oc(),core.Rb(0,\"div\",0),core.Wb(1,\"div\",1),core.nc(2),core.Vb())},styles:[\".agm-map-container-inner[_ngcontent-%COMP%] {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .agm-map-content[_ngcontent-%COMP%] {\\n      display:none;\\n    }\"]}),AgmMap._mapOptionsAttributes=[\"disableDoubleClickZoom\",\"scrollwheel\",\"draggable\",\"draggableCursor\",\"draggingCursor\",\"keyboardShortcuts\",\"zoomControl\",\"zoomControlOptions\",\"styles\",\"streetViewControl\",\"streetViewControlOptions\",\"zoom\",\"mapTypeControl\",\"mapTypeControlOptions\",\"minZoom\",\"maxZoom\",\"panControl\",\"panControlOptions\",\"rotateControl\",\"rotateControlOptions\",\"fullscreenControl\",\"fullscreenControlOptions\",\"scaleControl\",\"scaleControlOptions\",\"mapTypeId\",\"clickableIcons\",\"gestureHandling\",\"tilt\",\"restriction\"],AgmMap=AgmMap_1=Object(tslib_es6.__decorate)([Object(tslib_es6.__param)(2,Object(core.p)(core.B)),Object(tslib_es6.__metadata)(\"design:paramtypes\",[core.l,agm_core_GoogleMapsAPIWrapper,Object,agm_core_FitBoundsService,core.z])],AgmMap),AgmMap})();var AgmMarker_1;let markerId=0,agm_core_AgmMarker=(()=>{let AgmMarker=AgmMarker_1=class{constructor(_markerManager){this._markerManager=_markerManager,this.draggable=!1,this.visible=!0,this.openInfoWindow=!0,this.opacity=1,this.zIndex=1,this.clickable=!0,this.animationChange=new core.n,this.markerClick=new core.n,this.markerDblClick=new core.n,this.markerRightClick=new core.n,this.dragStart=new core.n,this.drag=new core.n,this.dragEnd=new core.n,this.mouseOver=new core.n,this.mouseOut=new core.n,this.infoWindow=new core.D,this._markerAddedToManger=!1,this._observableSubscriptions=[],this._fitBoundsDetails$=new ReplaySubject.a(1),this._id=(markerId++).toString()}ngAfterContentInit(){this.handleInfoWindowUpdate(),this.infoWindow.changes.subscribe(()=>this.handleInfoWindowUpdate())}handleInfoWindowUpdate(){if(this.infoWindow.length>1)throw new Error(\"Expected no more than one info window.\");this.infoWindow.forEach(marker=>{marker.hostMarker=this})}ngOnChanges(changes){if(\"string\"==typeof this.latitude&&(this.latitude=Number(this.latitude)),\"string\"==typeof this.longitude&&(this.longitude=Number(this.longitude)),\"number\"==typeof this.latitude&&\"number\"==typeof this.longitude){if(!this._markerAddedToManger)return this._markerManager.addMarker(this),this._updateFitBoundsDetails(),this._markerAddedToManger=!0,void this._addEventListeners();(changes.latitude||changes.longitude)&&(this._markerManager.updateMarkerPosition(this),this._updateFitBoundsDetails()),changes.title&&this._markerManager.updateTitle(this),changes.label&&this._markerManager.updateLabel(this),changes.draggable&&this._markerManager.updateDraggable(this),changes.iconUrl&&this._markerManager.updateIcon(this),changes.opacity&&this._markerManager.updateOpacity(this),changes.visible&&this._markerManager.updateVisible(this),changes.zIndex&&this._markerManager.updateZIndex(this),changes.clickable&&this._markerManager.updateClickable(this),changes.animation&&this._markerManager.updateAnimation(this)}}getFitBoundsDetails$(){return this._fitBoundsDetails$.asObservable()}_updateFitBoundsDetails(){this._fitBoundsDetails$.next({latLng:{lat:this.latitude,lng:this.longitude}})}_addEventListeners(){const cs=this._markerManager.createEventObservable(\"click\",this).subscribe(()=>{this.openInfoWindow&&this.infoWindow.forEach(infoWindow=>infoWindow.open()),this.markerClick.emit(this)});this._observableSubscriptions.push(cs);const dcs=this._markerManager.createEventObservable(\"dblclick\",this).subscribe(()=>{this.markerDblClick.emit(null)});this._observableSubscriptions.push(dcs);const rc=this._markerManager.createEventObservable(\"rightclick\",this).subscribe(()=>{this.markerRightClick.emit(null)});this._observableSubscriptions.push(rc);const ds=this._markerManager.createEventObservable(\"dragstart\",this).subscribe(e=>{this.dragStart.emit({coords:{lat:e.latLng.lat(),lng:e.latLng.lng()}})});this._observableSubscriptions.push(ds);const d=this._markerManager.createEventObservable(\"drag\",this).subscribe(e=>{this.drag.emit({coords:{lat:e.latLng.lat(),lng:e.latLng.lng()}})});this._observableSubscriptions.push(d);const de=this._markerManager.createEventObservable(\"dragend\",this).subscribe(e=>{this.dragEnd.emit({coords:{lat:e.latLng.lat(),lng:e.latLng.lng()}})});this._observableSubscriptions.push(de);const mover=this._markerManager.createEventObservable(\"mouseover\",this).subscribe(e=>{this.mouseOver.emit({coords:{lat:e.latLng.lat(),lng:e.latLng.lng()}})});this._observableSubscriptions.push(mover);const mout=this._markerManager.createEventObservable(\"mouseout\",this).subscribe(e=>{this.mouseOut.emit({coords:{lat:e.latLng.lat(),lng:e.latLng.lng()}})});this._observableSubscriptions.push(mout);const anChng=this._markerManager.createEventObservable(\"animation_changed\",this).subscribe(()=>{this.animationChange.emit(this.animation)});this._observableSubscriptions.push(anChng)}id(){return this._id}toString(){return\"AgmMarker-\"+this._id.toString()}ngOnDestroy(){this._markerManager.deleteMarker(this),this._observableSubscriptions.forEach(s=>s.unsubscribe())}};return AgmMarker.ɵfac=function(t){return new(t||AgmMarker)(core.Qb(agm_core_MarkerManager))},AgmMarker.ɵdir=core.Lb({type:AgmMarker,selectors:[[\"agm-marker\"]],contentQueries:function(rf,ctx,dirIndex){if(1&rf&&core.Jb(dirIndex,agm_core_AgmInfoWindow,!1),2&rf){let _t;core.Bc(_t=core.hc())&&(ctx.infoWindow=_t)}},inputs:{latitude:\"latitude\",longitude:\"longitude\",title:\"title\",label:\"label\",draggable:[\"markerDraggable\",\"draggable\"],iconUrl:\"iconUrl\",openInfoWindow:\"openInfoWindow\",opacity:\"opacity\",visible:\"visible\",zIndex:\"zIndex\",animation:\"animation\",clickable:[\"markerClickable\",\"clickable\"]},outputs:{markerClick:\"markerClick\",dragStart:\"dragStart\",drag:\"drag\",dragEnd:\"dragEnd\",mouseOver:\"mouseOver\",mouseOut:\"mouseOut\",animationChange:\"animationChange\",markerDblClick:\"markerDblClick\",markerRightClick:\"markerRightClick\"},features:[core.Bb([{provide:FitBoundsAccessor,useExisting:Object(core.X)(()=>AgmMarker_1)}]),core.Ab]}),AgmMarker=AgmMarker_1=Object(tslib_es6.__decorate)([Object(tslib_es6.__metadata)(\"design:paramtypes\",[agm_core_MarkerManager])],AgmMarker),AgmMarker})();class WindowRef{getNativeWindow(){return window}}class DocumentRef{getNativeDocument(){return document}}const BROWSER_GLOBALS_PROVIDERS=[WindowRef,DocumentRef];var GoogleMapsScriptProtocol=function(GoogleMapsScriptProtocol){return GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.HTTP=1]=\"HTTP\",GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.HTTPS=2]=\"HTTPS\",GoogleMapsScriptProtocol[GoogleMapsScriptProtocol.AUTO=3]=\"AUTO\",GoogleMapsScriptProtocol}({});const LAZY_MAPS_API_CONFIG=new core.q(\"angular-google-maps LAZY_MAPS_API_CONFIG\");let agm_core_LazyMapsAPILoader=(()=>{let LazyMapsAPILoader=class extends agm_core_MapsAPILoader{constructor(config=null,w,d,localeId){super(),this.localeId=localeId,this._SCRIPT_ID=\"agmGoogleMapsApiScript\",this.callbackName=\"agmLazyMapsAPILoader\",this._config=config||{},this._windowRef=w,this._documentRef=d}load(){const window=this._windowRef.getNativeWindow();if(window.google&&window.google.maps)return Promise.resolve();if(this._scriptLoadingPromise)return this._scriptLoadingPromise;const scriptOnPage=this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);if(scriptOnPage)return this._assignScriptLoadingPromise(scriptOnPage),this._scriptLoadingPromise;const script=this._documentRef.getNativeDocument().createElement(\"script\");return script.type=\"text/javascript\",script.async=!0,script.defer=!0,script.id=this._SCRIPT_ID,script.src=this._getScriptSrc(this.callbackName),this._assignScriptLoadingPromise(script),this._documentRef.getNativeDocument().body.appendChild(script),this._scriptLoadingPromise}_assignScriptLoadingPromise(scriptElem){this._scriptLoadingPromise=new Promise((resolve,reject)=>{this._windowRef.getNativeWindow()[this.callbackName]=()=>{resolve()},scriptElem.onerror=error=>{reject(error)}})}_getScriptSrc(callbackName){let protocol;switch(this._config&&this._config.protocol||GoogleMapsScriptProtocol.HTTPS){case GoogleMapsScriptProtocol.AUTO:protocol=\"\";break;case GoogleMapsScriptProtocol.HTTP:protocol=\"http:\";break;case GoogleMapsScriptProtocol.HTTPS:protocol=\"https:\"}const queryParams={v:this._config.apiVersion||\"quarterly\",callback:callbackName,key:this._config.apiKey,client:this._config.clientId,channel:this._config.channel,libraries:this._config.libraries,region:this._config.region,language:this._config.language||\"en-US\"!==this.localeId?this.localeId:null};return`${protocol}//${this._config.hostAndPath||\"maps.googleapis.com/maps/api/js\"}?${Object.keys(queryParams).filter(k=>null!=queryParams[k]).filter(k=>!Array.isArray(queryParams[k])||Array.isArray(queryParams[k])&&queryParams[k].length>0).map(k=>{let i=queryParams[k];return Array.isArray(i)?{key:k,value:i.join(\",\")}:{key:k,value:queryParams[k]}}).map(entry=>`${entry.key}=${entry.value}`).join(\"&\")}`}};return LazyMapsAPILoader.ɵfac=function(t){return new(t||LazyMapsAPILoader)(core.dc(LAZY_MAPS_API_CONFIG,8),core.dc(WindowRef),core.dc(DocumentRef),core.dc(core.u))},LazyMapsAPILoader.ɵprov=core.Mb({token:LazyMapsAPILoader,factory:function(t){return LazyMapsAPILoader.ɵfac(t)}}),LazyMapsAPILoader=Object(tslib_es6.__decorate)([Object(tslib_es6.__param)(0,Object(core.A)()),Object(tslib_es6.__param)(0,Object(core.p)(LAZY_MAPS_API_CONFIG)),Object(tslib_es6.__param)(3,Object(core.p)(core.u)),Object(tslib_es6.__metadata)(\"design:paramtypes\",[Object,WindowRef,DocumentRef,String])],LazyMapsAPILoader),LazyMapsAPILoader})();var AgmCoreModule_1;let agm_core_AgmCoreModule=(()=>{let AgmCoreModule=AgmCoreModule_1=class{static forRoot(lazyMapsAPILoaderConfig){return{ngModule:AgmCoreModule_1,providers:[...BROWSER_GLOBALS_PROVIDERS,{provide:agm_core_MapsAPILoader,useClass:agm_core_LazyMapsAPILoader},{provide:LAZY_MAPS_API_CONFIG,useValue:lazyMapsAPILoaderConfig}]}}};return AgmCoreModule.ɵmod=core.Ob({type:AgmCoreModule}),AgmCoreModule.ɵinj=core.Nb({factory:function(t){return new(t||AgmCoreModule)}}),AgmCoreModule})();var ui_module=__webpack_require__(\"4zvT\"),router=__webpack_require__(\"tyNb\"),pagetitle_component=__webpack_require__(\"V5ls\");const google_component_c0=[\"streetviewMap\"],_c1=[\"streetviewPano\"];function GoogleComponent_agm_marker_19_Template(rf,ctx){if(1&rf&&core.Rb(0,\"agm-marker\",18),2&rf){const marker_r3=ctx.$implicit;core.pc(\"latitude\",marker_r3.latitude)(\"longitude\",marker_r3.longitude)}}const routes=[{path:\"google\",component:(()=>{class GoogleComponent{constructor(platformId,mapsAPILoader){this.platformId=platformId,this.mapsAPILoader=mapsAPILoader,this.longitude=20.728218,this.latitude=52.128973}ngOnInit(){this.breadCrumbItems=[{label:\"Maps\"},{label:\"Google Maps\",active:!0}],this._initPanorama(),this._fetchData()}_initPanorama(){Object(common.z)(this.platformId)&&this.mapsAPILoader.load().then(()=>{const center={lat:42.345573,lng:-71.098326},map=new window.google.maps.Map(this.streetviewMap.nativeElement,{center:center,zoom:12,scrollwheel:!1}),panorama=new window.google.maps.StreetViewPanorama(this.streetviewPano.nativeElement,{position:center,pov:{heading:34,pitch:10},scrollwheel:!1});map.setStreetView(panorama)})}placeMarker(position){this.markers.push({latitude:position.coords.lat,longitude:position.coords.lng})}_fetchData(){this.markers=[{latitude:52.228973,longitude:20.728218}]}}return GoogleComponent.ɵfac=function(t){return new(t||GoogleComponent)(core.Qb(core.B),core.Qb(agm_core_MapsAPILoader))},GoogleComponent.ɵcmp=core.Kb({type:GoogleComponent,selectors:[[\"app-google\"]],viewQuery:function(rf,ctx){if(1&rf&&(core.Kc(google_component_c0,!0),core.Kc(_c1,!0)),2&rf){let _t;core.Bc(_t=core.hc())&&(ctx.streetviewMap=_t.first),core.Bc(_t=core.hc())&&(ctx.streetviewPano=_t.first)}},decls:42,vars:14,consts:[[1,\"container-fluid\"],[\"title\",\"Google Maps\",3,\"breadcrumbItems\"],[1,\"row\"],[1,\"col-lg-6\"],[1,\"card\"],[1,\"card-body\"],[1,\"card-title\",\"mb-3\"],[1,\"card-title-dsec\"],[2,\"height\",\"300px\",3,\"latitude\",\"longitude\"],[2,\"height\",\"300px\",3,\"latitude\",\"longitude\",\"mapClick\"],[3,\"latitude\",\"longitude\",4,\"ngFor\",\"ngForOf\"],[1,\"mb-3\",\"card-title\"],[\"id\",\"streetview-container\"],[\"id\",\"streetview-map\"],[\"streetviewMap\",\"\"],[\"id\",\"streetview-pano\",2,\"height\",\"300px\"],[\"streetviewPano\",\"\"],[3,\"latitude\",\"longitude\",\"radius\",\"fillColor\",\"circleDraggable\",\"editable\"],[3,\"latitude\",\"longitude\"]],template:function(rf,ctx){1&rf&&(core.Wb(0,\"div\",0),core.Rb(1,\"app-page-title\",1),core.Wb(2,\"div\",2),core.Wb(3,\"div\",3),core.Wb(4,\"div\",4),core.Wb(5,\"div\",5),core.Wb(6,\"h4\",6),core.Oc(7,\"Basic\"),core.Vb(),core.Wb(8,\"p\",7),core.Oc(9,\"Example of google maps.\"),core.Vb(),core.Rb(10,\"agm-map\",8),core.Vb(),core.Vb(),core.Vb(),core.Wb(11,\"div\",3),core.Wb(12,\"div\",4),core.Wb(13,\"div\",5),core.Wb(14,\"h4\",6),core.Oc(15,\"Markers\"),core.Vb(),core.Wb(16,\"p\",7),core.Oc(17,\"Example of google maps.\"),core.Vb(),core.Wb(18,\"agm-map\",9),core.gc(\"mapClick\",function($event){return ctx.placeMarker($event)}),core.Mc(19,GoogleComponent_agm_marker_19_Template,1,2,\"agm-marker\",10),core.Vb(),core.Vb(),core.Vb(),core.Vb(),core.Vb(),core.Wb(20,\"div\",2),core.Wb(21,\"div\",3),core.Wb(22,\"div\",4),core.Wb(23,\"div\",5),core.Wb(24,\"h4\",11),core.Oc(25,\"Street View Panoramas\"),core.Vb(),core.Wb(26,\"p\",7),core.Oc(27,\"Example of google maps.\"),core.Vb(),core.Wb(28,\"div\",12),core.Rb(29,\"div\",13,14),core.Rb(31,\"div\",15,16),core.Vb(),core.Vb(),core.Vb(),core.Vb(),core.Wb(33,\"div\",3),core.Wb(34,\"div\",4),core.Wb(35,\"div\",5),core.Wb(36,\"h4\",11),core.Oc(37,\"Location\"),core.Vb(),core.Wb(38,\"p\",7),core.Oc(39,\"Example of google maps.\"),core.Vb(),core.Wb(40,\"agm-map\",8),core.Rb(41,\"agm-circle\",17),core.Vb(),core.Vb(),core.Vb(),core.Vb(),core.Vb(),core.Vb()),2&rf&&(core.Cb(1),core.pc(\"breadcrumbItems\",ctx.breadCrumbItems),core.Cb(9),core.pc(\"latitude\",ctx.latitude)(\"longitude\",ctx.longitude),core.Cb(8),core.pc(\"latitude\",ctx.latitude)(\"longitude\",ctx.longitude),core.Cb(1),core.pc(\"ngForOf\",ctx.markers),core.Cb(21),core.pc(\"latitude\",ctx.latitude)(\"longitude\",ctx.longitude),core.Cb(1),core.pc(\"latitude\",ctx.latitude)(\"longitude\",ctx.longitude)(\"radius\",9e3)(\"fillColor\",\"red\")(\"circleDraggable\",!0)(\"editable\",!0))},directives:[pagetitle_component.a,agm_core_AgmMap,common.l,agm_core_AgmCircle,agm_core_AgmMarker],styles:[\"\"]}),GoogleComponent})()}];let maps_routing_module_MapsRoutingModule=(()=>{class MapsRoutingModule{}return MapsRoutingModule.ɵmod=core.Ob({type:MapsRoutingModule}),MapsRoutingModule.ɵinj=core.Nb({factory:function(t){return new(t||MapsRoutingModule)},imports:[[router.f.forChild(routes)],router.f]}),MapsRoutingModule})(),maps_module_MapsModule=(()=>{class MapsModule{}return MapsModule.ɵmod=core.Ob({type:MapsModule}),MapsModule.ɵinj=core.Nb({factory:function(t){return new(t||MapsModule)},imports:[[common.c,maps_routing_module_MapsRoutingModule,ui_module.a,agm_core_AgmCoreModule.forRoot({apiKey:\"AIzaSyAbvyBxmMbFhrzP9Z8moyYr6dCr-pzjhBE\"})]]}),MapsModule})()}}]);","name":"21-es2015.3f320794309a30aabacd.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[21],{\n\n/***/ \"MWin\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"MapsModule\", function() { return /* binding */ maps_module_MapsModule; });\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/ng2-flatpickr/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(\"KhPJ\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 1 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js\nvar BehaviorSubject = __webpack_require__(\"2Vo4\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/from.js + 6 modules\nvar from = __webpack_require__(\"Cfvw\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js\nvar timer = __webpack_require__(\"PqYM\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js\nvar isArray = __webpack_require__(\"DH7j\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isFunction.js\nvar isFunction = __webpack_require__(\"n6bG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js\n\n\n\n\nfunction fromEventPattern(addHandler, removeHandler, resultSelector) {\n    if (resultSelector) {\n        return fromEventPattern(addHandler, removeHandler).pipe(Object(map[\"a\" /* map */])(args => Object(isArray[\"a\" /* isArray */])(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);\n        let retValue;\n        try {\n            retValue = addHandler(handler);\n        }\n        catch (err) {\n            subscriber.error(err);\n            return undefined;\n        }\n        if (!Object(isFunction[\"a\" /* isFunction */])(removeHandler)) {\n            return undefined;\n        }\n        return () => removeHandler(handler, retValue);\n    });\n}\n//# sourceMappingURL=fromEventPattern.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js\nvar ReplaySubject = __webpack_require__(\"jtHE\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/AsyncSubject.js\n\n\nclass AsyncSubject_AsyncSubject extends Subject[\"a\" /* Subject */] {\n    constructor() {\n        super(...arguments);\n        this.value = null;\n        this.hasNext = false;\n        this.hasCompleted = false;\n    }\n    _subscribe(subscriber) {\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        else if (this.hasCompleted && this.hasNext) {\n            subscriber.next(this.value);\n            subscriber.complete();\n            return Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        return super._subscribe(subscriber);\n    }\n    next(value) {\n        if (!this.hasCompleted) {\n            this.value = value;\n            this.hasNext = true;\n        }\n    }\n    error(error) {\n        if (!this.hasCompleted) {\n            super.error(error);\n        }\n    }\n    complete() {\n        this.hasCompleted = true;\n        if (this.hasNext) {\n            super.next(this.value);\n        }\n        super.complete();\n    }\n}\n//# sourceMappingURL=AsyncSubject.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/canReportError.js\nvar canReportError = __webpack_require__(\"8Qeq\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js\nvar isScheduler = __webpack_require__(\"z+Ro\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js\n\n\n\n\n\n\nfunction bindCallback(callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (Object(isScheduler[\"a\" /* isScheduler */])(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(Object(map[\"a\" /* map */])((args) => Object(isArray[\"a\" /* isArray */])(args) ? resultSelector(...args) : resultSelector(args)));\n        }\n    }\n    return function (...args) {\n        const context = this;\n        let subject;\n        const params = {\n            context,\n            subject,\n            callbackFunc,\n            scheduler,\n        };\n        return new Observable[\"a\" /* Observable */](subscriber => {\n            if (!scheduler) {\n                if (!subject) {\n                    subject = new AsyncSubject_AsyncSubject();\n                    const handler = (...innerArgs) => {\n                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                        subject.complete();\n                    };\n                    try {\n                        callbackFunc.apply(context, [...args, handler]);\n                    }\n                    catch (err) {\n                        if (Object(canReportError[\"a\" /* canReportError */])(subject)) {\n                            subject.error(err);\n                        }\n                        else {\n                            console.warn(err);\n                        }\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                const state = {\n                    args, subscriber, params,\n                };\n                return scheduler.schedule(dispatch, 0, state);\n            }\n        });\n    };\n}\nfunction dispatch(state) {\n    const self = this;\n    const { args, subscriber, params } = state;\n    const { callbackFunc, context, scheduler } = params;\n    let { subject } = params;\n    if (!subject) {\n        subject = params.subject = new AsyncSubject_AsyncSubject();\n        const handler = (...innerArgs) => {\n            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n            this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));\n        };\n        try {\n            callbackFunc.apply(context, [...args, handler]);\n        }\n        catch (err) {\n            subject.error(err);\n        }\n    }\n    this.add(subject.subscribe(subscriber));\n}\nfunction dispatchNext(state) {\n    const { value, subject } = state;\n    subject.next(value);\n    subject.complete();\n}\nfunction dispatchError(state) {\n    const { err, subject } = state;\n    subject.error(err);\n}\n//# sourceMappingURL=bindCallback.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/throwError.js\nvar throwError = __webpack_require__(\"z6cu\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js\nvar mergeMap = __webpack_require__(\"5+tZ\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/innerSubscribe.js\nvar innerSubscribe = __webpack_require__(\"zx2A\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/sample.js\n\nfunction sample(notifier) {\n    return (source) => source.lift(new sample_SampleOperator(notifier));\n}\nclass sample_SampleOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const sampleSubscriber = new sample_SampleSubscriber(subscriber);\n        const subscription = source.subscribe(sampleSubscriber);\n        subscription.add(Object(innerSubscribe[\"c\" /* innerSubscribe */])(this.notifier, new innerSubscribe[\"a\" /* SimpleInnerSubscriber */](sampleSubscriber)));\n        return subscription;\n    }\n}\nclass sample_SampleSubscriber extends innerSubscribe[\"b\" /* SimpleOuterSubscriber */] {\n    constructor() {\n        super(...arguments);\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n    }\n    notifyNext() {\n        this.emitValue();\n    }\n    notifyComplete() {\n        this.emitValue();\n    }\n    emitValue() {\n        if (this.hasValue) {\n            this.hasValue = false;\n            this.destination.next(this.value);\n        }\n    }\n}\n//# sourceMappingURL=sample.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js\nvar shareReplay = __webpack_require__(\"UXun\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\nvar distinctUntilChanged = __webpack_require__(\"/uUt\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\nvar takeUntil = __webpack_require__(\"1G5W\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/skip.js\nvar skip = __webpack_require__(\"zP0r\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/multicast.js + 1 modules\nvar multicast = __webpack_require__(\"oB13\");\n\n// CONCATENATED MODULE: ./node_modules/@agm/core/__ivy_ngcc__/fesm2015/agm-core.js\n\n\n\n\n\n\nconst _c0 = [\"*\"];\nlet agm_core_MapsAPILoader = /*@__PURE__*/ (() => {\n    let MapsAPILoader = class MapsAPILoader {\n    };\n    MapsAPILoader.ɵfac = function MapsAPILoader_Factory(t) { return new (t || MapsAPILoader)(); };\n    MapsAPILoader.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: MapsAPILoader, factory: function (t) { return MapsAPILoader.ɵfac(t); } });\n    return MapsAPILoader;\n})();\nlet agm_core_GoogleMapsAPIWrapper = /*@__PURE__*/ (() => {\n    /**\n     * Wrapper class that handles the communication with the Google Maps Javascript\n     * API v3\n     */\n    let GoogleMapsAPIWrapper = class GoogleMapsAPIWrapper {\n        constructor(_loader, _zone) {\n            this._loader = _loader;\n            this._zone = _zone;\n            this._map =\n                new Promise((resolve) => { this._mapResolver = resolve; });\n        }\n        createMap(el, mapOptions) {\n            return this._zone.runOutsideAngular(() => {\n                return this._loader.load().then(() => {\n                    const map = new google.maps.Map(el, mapOptions);\n                    this._mapResolver(map);\n                    return;\n                });\n            });\n        }\n        setMapOptions(options) {\n            return this._zone.runOutsideAngular(() => {\n                this._map.then((m) => { m.setOptions(options); });\n            });\n        }\n        /**\n         * Creates a google map marker with the map context\n         */\n        createMarker(options = {}, addToMap = true) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    if (addToMap) {\n                        options.map = map;\n                    }\n                    return new google.maps.Marker(options);\n                });\n            });\n        }\n        createInfoWindow(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then(() => { return new google.maps.InfoWindow(options); });\n            });\n        }\n        /**\n         * Creates a google.map.Circle for the current map.\n         */\n        createCircle(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    if (typeof options.strokePosition === 'string') {\n                        options.strokePosition = google.maps.StrokePosition[options.strokePosition];\n                    }\n                    options.map = map;\n                    return new google.maps.Circle(options);\n                });\n            });\n        }\n        /**\n         * Creates a google.map.Rectangle for the current map.\n         */\n        createRectangle(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    options.map = map;\n                    return new google.maps.Rectangle(options);\n                });\n            });\n        }\n        createPolyline(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this.getNativeMap().then((map) => {\n                    let line = new google.maps.Polyline(options);\n                    line.setMap(map);\n                    return line;\n                });\n            });\n        }\n        createPolygon(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this.getNativeMap().then((map) => {\n                    let polygon = new google.maps.Polygon(options);\n                    polygon.setMap(map);\n                    return polygon;\n                });\n            });\n        }\n        /**\n         * Creates a new google.map.Data layer for the current map\n         */\n        createDataLayer(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then(m => {\n                    let data = new google.maps.Data(options);\n                    data.setMap(m);\n                    return data;\n                });\n            });\n        }\n        /**\n         * Creates a TransitLayer instance for a map\n         * @param {TransitLayerOptions} options - used for setting layer options\n         * @returns {Promise<TransitLayer>} a new transit layer object\n         */\n        createTransitLayer(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    let newLayer = new google.maps.TransitLayer();\n                    newLayer.setMap(options.visible ? map : null);\n                    return newLayer;\n                });\n            });\n        }\n        /**\n         * Creates a BicyclingLayer instance for a map\n         * @param {BicyclingLayerOptions} options - used for setting layer options\n         * @returns {Promise<BicyclingLayer>} a new bicycling layer object\n         */\n        createBicyclingLayer(options) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => {\n                    let newLayer = new google.maps.BicyclingLayer();\n                    newLayer.setMap(options.visible ? map : null);\n                    return newLayer;\n                });\n            });\n        }\n        /**\n         * Determines if given coordinates are insite a Polygon path.\n         */\n        containsLocation(latLng, polygon) {\n            return google.maps.geometry.poly.containsLocation(latLng, polygon);\n        }\n        subscribeToMapEvent(eventName) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._map.then((m) => {\n                    m.addListener(eventName, (arg) => { this._zone.run(() => observer.next(arg)); });\n                });\n            });\n        }\n        clearInstanceListeners() {\n            return this._zone.runOutsideAngular(() => {\n                this._map.then((map) => {\n                    google.maps.event.clearInstanceListeners(map);\n                });\n            });\n        }\n        setCenter(latLng) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.setCenter(latLng));\n            });\n        }\n        getZoom() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getZoom());\n            });\n        }\n        getBounds() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getBounds());\n            });\n        }\n        getMapTypeId() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getMapTypeId());\n            });\n        }\n        setZoom(zoom) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.setZoom(zoom));\n            });\n        }\n        getCenter() {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.getCenter());\n            });\n        }\n        panTo(latLng) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panTo(latLng));\n            });\n        }\n        panBy(x, y) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panBy(x, y));\n            });\n        }\n        fitBounds(latLng, padding) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.fitBounds(latLng, padding));\n            });\n        }\n        panToBounds(latLng, padding) {\n            return this._zone.runOutsideAngular(() => {\n                return this._map.then((map) => map.panToBounds(latLng, padding));\n            });\n        }\n        /**\n         * Returns the native Google Maps Map instance. Be careful when using this instance directly.\n         */\n        getNativeMap() { return this._map; }\n        /**\n         * Triggers the given event name on the map instance.\n         */\n        triggerMapEvent(eventName) {\n            return this._map.then((m) => google.maps.event.trigger(m, eventName));\n        }\n    };\n    GoogleMapsAPIWrapper.ɵfac = function GoogleMapsAPIWrapper_Factory(t) { return new (t || GoogleMapsAPIWrapper)(core[\"dc\" /* ɵɵinject */](agm_core_MapsAPILoader), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    GoogleMapsAPIWrapper.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: GoogleMapsAPIWrapper, factory: function (t) { return GoogleMapsAPIWrapper.ɵfac(t); } });\n    GoogleMapsAPIWrapper = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_MapsAPILoader, core[\"z\" /* NgZone */]])\n    ], GoogleMapsAPIWrapper);\n    return GoogleMapsAPIWrapper;\n})();\nlet agm_core_LayerManager = /*@__PURE__*/ (() => {\n    /**\n     * This class manages Transit and Bicycling Layers for a Google Map instance.\n     */\n    let LayerManager = class LayerManager {\n        constructor(_wrapper) {\n            this._wrapper = _wrapper;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a transit layer to a map instance.\n         * @param {AgmTransitLayer} layer - a TransitLayer object\n         * @param {TransitLayerOptions} options - TransitLayerOptions options\n         * @returns void\n         */\n        addTransitLayer(layer, options) {\n            const newLayer = this._wrapper.createTransitLayer(options);\n            this._layers.set(layer, newLayer);\n        }\n        /**\n         * Adds a bicycling layer to a map instance.\n         * @param {AgmBicyclingLayer} layer - a bicycling layer object\n         * @param {BicyclingLayerOptions} options - BicyclingLayer options\n         * @returns void\n         */\n        addBicyclingLayer(layer, options) {\n            const newLayer = this._wrapper.createBicyclingLayer(options);\n            this._layers.set(layer, newLayer);\n        }\n        /**\n         * Deletes a map layer\n         * @param {AgmTransitLayer|AgmBicyclingLayer} layer - the layer to delete\n         * @returns  Promise<void>\n         */\n        deleteLayer(layer) {\n            return this._layers.get(layer).then(currentLayer => {\n                currentLayer.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n        /**\n         * Hide/Show a google map layer\n         * @param { AgmTransitLayer|AgmBicyclingLayer} layer - the layer to hide/show\n         * @param {TransitLayerOptions|BicyclingLayerOptions} options - used to set visibility of the layer\n         * @returns Promise<void>\n         */\n        toggleLayerVisibility(layer, options) {\n            return this._layers.get(layer).then(currentLayer => {\n                if (!options.visible) {\n                    currentLayer.setMap(null);\n                    return;\n                }\n                else {\n                    return this._wrapper.getNativeMap().then((map) => {\n                        currentLayer.setMap(map);\n                    });\n                }\n            });\n        }\n    };\n    LayerManager.ɵfac = function LayerManager_Factory(t) { return new (t || LayerManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper)); };\n    LayerManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: LayerManager, factory: function (t) { return LayerManager.ɵfac(t); } });\n    LayerManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper])\n    ], LayerManager);\n    return LayerManager;\n})();\nlet layerId = 0;\nlet agm_core_AgmBicyclingLayer = /*@__PURE__*/ (() => {\n    /*\n     * This directive adds a bicycling layer to a google map instance\n     * <agm-bicycling-layer [visible]=\"true|false\"> <agm-bicycling-layer>\n     * */\n    let AgmBicyclingLayer = class AgmBicyclingLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId++).toString();\n            /**\n             * Hide/show bicycling layer\n             */\n            this.visible = true;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addBicyclingLayer(this, { visible: this.visible });\n            this._addedToManager = true;\n        }\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            if (changes['visible'] != null) {\n                this._manager.toggleLayerVisibility(this, { visible: changes['visible'].currentValue });\n            }\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmBicyclingLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteLayer(this);\n        }\n    };\n    AgmBicyclingLayer.ɵfac = function AgmBicyclingLayer_Factory(t) { return new (t || AgmBicyclingLayer)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_LayerManager)); };\n    AgmBicyclingLayer.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmBicyclingLayer, selectors: [[\"agm-bicycling-layer\"]], inputs: { visible: \"visible\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmBicyclingLayer = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_LayerManager])\n    ], AgmBicyclingLayer);\n    return AgmBicyclingLayer;\n})();\nlet agm_core_CircleManager = /*@__PURE__*/ (() => {\n    let CircleManager = class CircleManager {\n        constructor(_apiWrapper, _zone) {\n            this._apiWrapper = _apiWrapper;\n            this._zone = _zone;\n            this._circles = new Map();\n        }\n        addCircle(circle) {\n            this._circles.set(circle, this._apiWrapper.createCircle({\n                center: { lat: circle.latitude, lng: circle.longitude },\n                clickable: circle.clickable,\n                draggable: circle.draggable,\n                editable: circle.editable,\n                fillColor: circle.fillColor,\n                fillOpacity: circle.fillOpacity,\n                radius: circle.radius,\n                strokeColor: circle.strokeColor,\n                strokeOpacity: circle.strokeOpacity,\n                strokePosition: circle.strokePosition,\n                strokeWeight: circle.strokeWeight,\n                visible: circle.visible,\n                zIndex: circle.zIndex,\n            }));\n        }\n        /**\n         * Removes the given circle from the map.\n         */\n        removeCircle(circle) {\n            return this._circles.get(circle).then((c) => {\n                c.setMap(null);\n                this._circles.delete(circle);\n            });\n        }\n        setOptions(circle, options) {\n            return this._circles.get(circle).then((c) => {\n                if (typeof options.strokePosition === 'string') {\n                    options.strokePosition = google.maps.StrokePosition[options.strokePosition];\n                }\n                c.setOptions(options);\n            });\n        }\n        getBounds(circle) {\n            return this._circles.get(circle).then((c) => c.getBounds());\n        }\n        getCenter(circle) {\n            return this._circles.get(circle).then((c) => c.getCenter());\n        }\n        getRadius(circle) {\n            return this._circles.get(circle).then((c) => c.getRadius());\n        }\n        setCenter(circle) {\n            return this._circles.get(circle).then((c) => { return c.setCenter({ lat: circle.latitude, lng: circle.longitude }); });\n        }\n        setEditable(circle) {\n            return this._circles.get(circle).then((c) => { return c.setEditable(circle.editable); });\n        }\n        setDraggable(circle) {\n            return this._circles.get(circle).then((c) => { return c.setDraggable(circle.draggable); });\n        }\n        setVisible(circle) {\n            return this._circles.get(circle).then((c) => { return c.setVisible(circle.visible); });\n        }\n        setRadius(circle) {\n            return this._circles.get(circle).then((c) => { return c.setRadius(circle.radius); });\n        }\n        getNativeCircle(circle) {\n            return this._circles.get(circle);\n        }\n        createEventObservable(eventName, circle) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                let listener = null;\n                this._circles.get(circle).then((c) => {\n                    listener = c.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n                return () => {\n                    if (listener !== null) {\n                        listener.remove();\n                    }\n                };\n            });\n        }\n    };\n    CircleManager.ɵfac = function CircleManager_Factory(t) { return new (t || CircleManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    CircleManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: CircleManager, factory: function (t) { return CircleManager.ɵfac(t); } });\n    CircleManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], CircleManager);\n    return CircleManager;\n})();\nvar AgmCircle_1;\nlet agm_core_AgmCircle = /*@__PURE__*/ (() => {\n    let AgmCircle = AgmCircle_1 = class AgmCircle {\n        constructor(_manager) {\n            this._manager = _manager;\n            /**\n             * Indicates whether this Circle handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this circle over the map. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this circle by dragging the control points shown at\n             * the center and around the circumference of the circle. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * The radius in meters on the Earth's surface.\n             */\n            this.radius = 0;\n            /**\n             * The stroke position. Defaults to CENTER.\n             * This property is not supported on Internet Explorer 8 and earlier.\n             */\n            this.strokePosition = 'CENTER';\n            /**\n             * The stroke width in pixels.\n             */\n            this.strokeWeight = 0;\n            /**\n             * Whether this circle is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the circle's center is changed.\n             */\n            this.centerChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks on the circle.\n             */\n            this.circleClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks on the circle.\n             */\n            this.circleDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is repeatedly fired while the user drags the circle.\n             */\n            this.drag = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user stops dragging the circle.\n             */\n            this.dragEnd = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user starts dragging the circle.\n             */\n            this.dragStart = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the circle.\n             */\n            this.mouseDown = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the circle.\n             */\n            this.mouseMove = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on circle mouseout.\n             */\n            this.mouseOut = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on circle mouseover.\n             */\n            this.mouseOver = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mouseup event is fired on the circle.\n             */\n            this.mouseUp = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the circle's radius is changed.\n             */\n            this.radiusChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the circle is right-clicked on.\n             */\n            this.rightClick = new core[\"n\" /* EventEmitter */]();\n            this._circleAddedToManager = false;\n            this._eventSubscriptions = [];\n        }\n        /** @internal */\n        ngOnInit() {\n            this._manager.addCircle(this);\n            this._circleAddedToManager = true;\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._circleAddedToManager) {\n                return;\n            }\n            if (changes['latitude'] || changes['longitude']) {\n                this._manager.setCenter(this);\n            }\n            if (changes['editable']) {\n                this._manager.setEditable(this);\n            }\n            if (changes['draggable']) {\n                this._manager.setDraggable(this);\n            }\n            if (changes['visible']) {\n                this._manager.setVisible(this);\n            }\n            if (changes['radius']) {\n                this._manager.setRadius(this);\n            }\n            this._updateCircleOptionsChanges(changes);\n        }\n        _updateCircleOptionsChanges(changes) {\n            let options = {};\n            let optionKeys = Object.keys(changes).filter(k => AgmCircle_1._mapOptions.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            if (optionKeys.length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _registerEventListeners() {\n            let events = new Map();\n            events.set('center_changed', this.centerChange);\n            events.set('click', this.circleClick);\n            events.set('dblclick', this.circleDblClick);\n            events.set('drag', this.drag);\n            events.set('dragend', this.dragEnd);\n            events.set('dragstart', this.dragStart);\n            events.set('mousedown', this.mouseDown);\n            events.set('mousemove', this.mouseMove);\n            events.set('mouseout', this.mouseOut);\n            events.set('mouseover', this.mouseOver);\n            events.set('mouseup', this.mouseUp);\n            events.set('radius_changed', this.radiusChange);\n            events.set('rightclick', this.rightClick);\n            events.forEach((eventEmitter, eventName) => {\n                this._eventSubscriptions.push(this._manager.createEventObservable(eventName, this).subscribe((value) => {\n                    switch (eventName) {\n                        case 'radius_changed':\n                            this._manager.getRadius(this).then((radius) => eventEmitter.emit(radius));\n                            break;\n                        case 'center_changed':\n                            this._manager.getCenter(this).then((center) => eventEmitter.emit({ lat: center.lat(), lng: center.lng() }));\n                            break;\n                        default:\n                            eventEmitter.emit({ coords: { lat: value.latLng.lat(), lng: value.latLng.lng() } });\n                    }\n                }));\n            });\n        }\n        /** @internal */\n        ngOnDestroy() {\n            this._eventSubscriptions.forEach(function (s) { s.unsubscribe(); });\n            this._eventSubscriptions = null;\n            this._manager.removeCircle(this);\n        }\n        /**\n         * Gets the LatLngBounds of this Circle.\n         */\n        getBounds() { return this._manager.getBounds(this); }\n        getCenter() { return this._manager.getCenter(this); }\n    };\n    AgmCircle.ɵfac = function AgmCircle_Factory(t) { return new (t || AgmCircle)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_CircleManager)); };\n    AgmCircle.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmCircle, selectors: [[\"agm-circle\"]], inputs: { clickable: \"clickable\", draggable: [\"circleDraggable\", \"draggable\"], editable: \"editable\", radius: \"radius\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", latitude: \"latitude\", longitude: \"longitude\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", zIndex: \"zIndex\" }, outputs: { centerChange: \"centerChange\", circleClick: \"circleClick\", circleDblClick: \"circleDblClick\", drag: \"drag\", dragEnd: \"dragEnd\", dragStart: \"dragStart\", mouseDown: \"mouseDown\", mouseMove: \"mouseMove\", mouseOut: \"mouseOut\", mouseOver: \"mouseOver\", mouseUp: \"mouseUp\", radiusChange: \"radiusChange\", rightClick: \"rightClick\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmCircle._mapOptions = [\n        'fillColor', 'fillOpacity', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight',\n        'visible', 'zIndex', 'clickable',\n    ];\n    AgmCircle = AgmCircle_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_CircleManager])\n    ], AgmCircle);\n    return AgmCircle;\n})();\nlet agm_core_DataLayerManager = /*@__PURE__*/ (() => {\n    /**\n     * Manages all Data Layers for a Google Map instance.\n     */\n    let DataLayerManager = class DataLayerManager {\n        constructor(_wrapper, _zone) {\n            this._wrapper = _wrapper;\n            this._zone = _zone;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a new Data Layer to the map.\n         */\n        addDataLayer(layer) {\n            const newLayer = this._wrapper.createDataLayer({\n                style: layer.style,\n            })\n                .then(d => {\n                if (layer.geoJson) {\n                    this.getDataFeatures(d, layer.geoJson).then(features => d.features = features);\n                }\n                return d;\n            });\n            this._layers.set(layer, newLayer);\n        }\n        deleteDataLayer(layer) {\n            this._layers.get(layer).then(l => {\n                l.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n        updateGeoJson(layer, geoJson) {\n            this._layers.get(layer).then(l => {\n                l.forEach(function (feature) {\n                    l.remove(feature);\n                    var index = l.features.indexOf(feature, 0);\n                    if (index > -1) {\n                        l.features.splice(index, 1);\n                    }\n                });\n                this.getDataFeatures(l, geoJson).then(features => l.features = features);\n            });\n        }\n        setDataOptions(layer, options) {\n            this._layers.get(layer).then(l => {\n                l.setControlPosition(options.controlPosition);\n                l.setControls(options.controls);\n                l.setDrawingMode(options.drawingMode);\n                l.setStyle(options.style);\n            });\n        }\n        /**\n         * Creates a Google Maps event listener for the given DataLayer as an Observable\n         */\n        createEventObservable(eventName, layer) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._layers.get(layer).then((d) => {\n                    d.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        /**\n         * Extract features from a geoJson using google.maps Data Class\n         * @param d : google.maps.Data class instance\n         * @param geoJson : url or geojson object\n         */\n        getDataFeatures(d, geoJson) {\n            return new Promise((resolve, reject) => {\n                if (typeof geoJson === 'object') {\n                    try {\n                        const features = d.addGeoJson(geoJson);\n                        resolve(features);\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n                else if (typeof geoJson === 'string') {\n                    d.loadGeoJson(geoJson, null, resolve);\n                }\n                else {\n                    reject(`Impossible to extract features from geoJson: wrong argument type`);\n                }\n            });\n        }\n    };\n    DataLayerManager.ɵfac = function DataLayerManager_Factory(t) { return new (t || DataLayerManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    DataLayerManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: DataLayerManager, factory: function (t) { return DataLayerManager.ɵfac(t); } });\n    DataLayerManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], DataLayerManager);\n    return DataLayerManager;\n})();\nvar AgmDataLayer_1;\nlet layerId$1 = 0;\nlet agm_core_AgmDataLayer = /*@__PURE__*/ (() => {\n    /**\n     * AgmDataLayer enables the user to add data layers to the map.\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from 'angular2/core';\n     * import { AgmMap, AgmDataLayer } from\n     * 'angular-google-maps/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  directives: [AgmMap, AgmDataLayer],\n     *  styles: [`\n     *    .agm-container {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     * <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     * \t  <agm-data-layer [geoJson]=\"geoJsonObject\" (layerClick)=\"clicked($event)\" [style]=\"styleFunc\">\n     * \t  </agm-data-layer>\n     * </agm-map>\n     *  `\n     * })\n     * export class MyMapCmp {\n     *   lat: number = -25.274449;\n     *   lng: number = 133.775060;\n     *   zoom: number = 5;\n     *\n     * clicked(clickEvent) {\n     *    console.log(clickEvent);\n     *  }\n     *\n     *  styleFunc(feature) {\n     *    return ({\n     *      clickable: false,\n     *      fillColor: feature.getProperty('color'),\n     *      strokeWeight: 1\n     *    });\n     *  }\n     *\n     *  geoJsonObject: Object = {\n     *    \"type\": \"FeatureCollection\",\n     *    \"features\": [\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"G\",\n     *          \"color\": \"blue\",\n     *          \"rank\": \"7\",\n     *          \"ascii\": \"71\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [123.61, -22.14], [122.38, -21.73], [121.06, -21.69], [119.66, -22.22], [119.00, -23.40],\n     *              [118.65, -24.76], [118.43, -26.07], [118.78, -27.56], [119.22, -28.57], [120.23, -29.49],\n     *              [121.77, -29.87], [123.57, -29.64], [124.45, -29.03], [124.71, -27.95], [124.80, -26.70],\n     *              [124.80, -25.60], [123.61, -25.64], [122.56, -25.64], [121.72, -25.72], [121.81, -26.62],\n     *              [121.86, -26.98], [122.60, -26.90], [123.57, -27.05], [123.57, -27.68], [123.35, -28.18],\n     *              [122.51, -28.38], [121.77, -28.26], [121.02, -27.91], [120.49, -27.21], [120.14, -26.50],\n     *              [120.10, -25.64], [120.27, -24.52], [120.67, -23.68], [121.72, -23.32], [122.43, -23.48],\n     *              [123.04, -24.04], [124.54, -24.28], [124.58, -23.20], [123.61, -22.14]\n     *            ]\n     *          ]\n     *        }\n     *      },\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"o\",\n     *          \"color\": \"red\",\n     *          \"rank\": \"15\",\n     *          \"ascii\": \"111\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [128.84, -25.76], [128.18, -25.60], [127.96, -25.52], [127.88, -25.52], [127.70, -25.60],\n     *              [127.26, -25.79], [126.60, -26.11], [126.16, -26.78], [126.12, -27.68], [126.21, -28.42],\n     *              [126.69, -29.49], [127.74, -29.80], [128.80, -29.72], [129.41, -29.03], [129.72, -27.95],\n     *              [129.68, -27.21], [129.33, -26.23], [128.84, -25.76]\n     *            ],\n     *            [\n     *              [128.45, -27.44], [128.32, -26.94], [127.70, -26.82], [127.35, -27.05], [127.17, -27.80],\n     *              [127.57, -28.22], [128.10, -28.42], [128.49, -27.80], [128.45, -27.44]\n     *            ]\n     *          ]\n     *        }\n     *      },\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"o\",\n     *          \"color\": \"yellow\",\n     *          \"rank\": \"15\",\n     *          \"ascii\": \"111\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [131.87, -25.76], [131.35, -26.07], [130.95, -26.78], [130.82, -27.64], [130.86, -28.53],\n     *              [131.26, -29.22], [131.92, -29.76], [132.45, -29.87], [133.06, -29.76], [133.72, -29.34],\n     *              [134.07, -28.80], [134.20, -27.91], [134.07, -27.21], [133.81, -26.31], [133.37, -25.83],\n     *              [132.71, -25.64], [131.87, -25.76]\n     *            ],\n     *            [\n     *              [133.15, -27.17], [132.71, -26.86], [132.09, -26.90], [131.74, -27.56], [131.79, -28.26],\n     *              [132.36, -28.45], [132.93, -28.34], [133.15, -27.76], [133.15, -27.17]\n     *            ]\n     *          ]\n     *        }\n     *      },\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"g\",\n     *          \"color\": \"blue\",\n     *          \"rank\": \"7\",\n     *          \"ascii\": \"103\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [138.12, -25.04], [136.84, -25.16], [135.96, -25.36], [135.26, -25.99], [135, -26.90],\n     *              [135.04, -27.91], [135.26, -28.88], [136.05, -29.45], [137.02, -29.49], [137.81, -29.49],\n     *              [137.94, -29.99], [137.90, -31.20], [137.85, -32.24], [136.88, -32.69], [136.45, -32.36],\n     *              [136.27, -31.80], [134.95, -31.84], [135.17, -32.99], [135.52, -33.43], [136.14, -33.76],\n     *              [137.06, -33.83], [138.12, -33.65], [138.86, -33.21], [139.30, -32.28], [139.30, -31.24],\n     *              [139.30, -30.14], [139.21, -28.96], [139.17, -28.22], [139.08, -27.41], [139.08, -26.47],\n     *              [138.99, -25.40], [138.73, -25.00], [138.12, -25.04]\n     *            ],\n     *            [\n     *              [137.50, -26.54], [136.97, -26.47], [136.49, -26.58], [136.31, -27.13], [136.31, -27.72],\n     *              [136.58, -27.99], [137.50, -28.03], [137.68, -27.68], [137.59, -26.78], [137.50, -26.54]\n     *            ]\n     *          ]\n     *        }\n     *      },\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"l\",\n     *          \"color\": \"green\",\n     *          \"rank\": \"12\",\n     *          \"ascii\": \"108\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [140.14, -21.04], [140.31, -29.42], [141.67, -29.49], [141.59, -20.92], [140.14, -21.04]\n     *            ]\n     *          ]\n     *        }\n     *      },\n     *      {\n     *        \"type\": \"Feature\",\n     *        \"properties\": {\n     *          \"letter\": \"e\",\n     *          \"color\": \"red\",\n     *          \"rank\": \"5\",\n     *          \"ascii\": \"101\"\n     *        },\n     *        \"geometry\": {\n     *          \"type\": \"Polygon\",\n     *          \"coordinates\": [\n     *            [\n     *              [144.14, -27.41], [145.67, -27.52], [146.86, -27.09], [146.82, -25.64], [146.25, -25.04],\n     *              [145.45, -24.68], [144.66, -24.60], [144.09, -24.76], [143.43, -25.08], [142.99, -25.40],\n     *              [142.64, -26.03], [142.64, -27.05], [142.64, -28.26], [143.30, -29.11], [144.18, -29.57],\n     *              [145.41, -29.64], [146.46, -29.19], [146.64, -28.72], [146.82, -28.14], [144.84, -28.42],\n     *              [144.31, -28.26], [144.14, -27.41]\n     *            ],\n     *            [\n     *              [144.18, -26.39], [144.53, -26.58], [145.19, -26.62], [145.72, -26.35], [145.81, -25.91],\n     *              [145.41, -25.68], [144.97, -25.68], [144.49, -25.64], [144, -25.99], [144.18, -26.39]\n     *            ]\n     *          ]\n     *        }\n     *      }\n     *    ]\n     *  };\n     * }\n     * ```\n     */\n    let AgmDataLayer = AgmDataLayer_1 = class AgmDataLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$1++).toString();\n            this._subscriptions = [];\n            /**\n             * This event is fired when a feature in the layer is clicked.\n             */\n            this.layerClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * The geoJson to be displayed\n             */\n            this.geoJson = null;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addDataLayer(this);\n            this._addedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const listeners = [\n                { name: 'click', handler: (ev) => this.layerClick.emit(ev) },\n            ];\n            listeners.forEach((obj) => {\n                const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmDataLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteDataLayer(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach(s => s.unsubscribe());\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            var geoJsonChange = changes['geoJson'];\n            if (geoJsonChange) {\n                this._manager.updateGeoJson(this, geoJsonChange.currentValue);\n            }\n            let dataOptions = {};\n            AgmDataLayer_1._dataOptionsAttributes.forEach(k => dataOptions[k] = changes.hasOwnProperty(k) ? changes[k].currentValue : this[k]);\n            this._manager.setDataOptions(this, dataOptions);\n        }\n    };\n    AgmDataLayer.ɵfac = function AgmDataLayer_Factory(t) { return new (t || AgmDataLayer)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_DataLayerManager)); };\n    AgmDataLayer.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmDataLayer, selectors: [[\"agm-data-layer\"]], inputs: { geoJson: \"geoJson\", style: \"style\" }, outputs: { layerClick: \"layerClick\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmDataLayer._dataOptionsAttributes = ['style'];\n    AgmDataLayer = AgmDataLayer_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_DataLayerManager])\n    ], AgmDataLayer);\n    return AgmDataLayer;\n})();\n/**\n * Class to implement when you what to be able to make it work with the auto fit bounds feature\n * of AGM.\n */\nclass FitBoundsAccessor {\n}\nlet agm_core_FitBoundsService = /*@__PURE__*/ (() => {\n    /**\n     * The FitBoundsService is responsible for computing the bounds of the a single map.\n     */\n    let FitBoundsService = class FitBoundsService {\n        constructor(loader) {\n            this._boundsChangeSampleTime$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](200);\n            this._includeInBounds$ = new BehaviorSubject[\"a\" /* BehaviorSubject */](new Map());\n            this.bounds$ = Object(from[\"a\" /* from */])(loader.load()).pipe(Object(mergeMap[\"a\" /* flatMap */])(() => this._includeInBounds$), sample(this._boundsChangeSampleTime$.pipe(Object(switchMap[\"a\" /* switchMap */])(time => Object(timer[\"a\" /* timer */])(0, time)))), Object(map[\"a\" /* map */])(includeInBounds => this._generateBounds(includeInBounds)), Object(shareReplay[\"a\" /* shareReplay */])(1));\n        }\n        _generateBounds(includeInBounds) {\n            const bounds = new google.maps.LatLngBounds();\n            includeInBounds.forEach(b => bounds.extend(b));\n            return bounds;\n        }\n        addToBounds(latLng) {\n            const id = this._createIdentifier(latLng);\n            if (this._includeInBounds$.value.has(id)) {\n                return;\n            }\n            const map = this._includeInBounds$.value;\n            map.set(id, latLng);\n            this._includeInBounds$.next(map);\n        }\n        removeFromBounds(latLng) {\n            const map = this._includeInBounds$.value;\n            map.delete(this._createIdentifier(latLng));\n            this._includeInBounds$.next(map);\n        }\n        changeFitBoundsChangeSampleTime(timeMs) {\n            this._boundsChangeSampleTime$.next(timeMs);\n        }\n        getBounds$() {\n            return this.bounds$;\n        }\n        _createIdentifier(latLng) {\n            return `${latLng.lat}+${latLng.lng}`;\n        }\n    };\n    FitBoundsService.ɵfac = function FitBoundsService_Factory(t) { return new (t || FitBoundsService)(core[\"dc\" /* ɵɵinject */](agm_core_MapsAPILoader)); };\n    FitBoundsService.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: FitBoundsService, factory: function (t) { return FitBoundsService.ɵfac(t); } });\n    FitBoundsService = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_MapsAPILoader])\n    ], FitBoundsService);\n    return FitBoundsService;\n})();\nlet agm_core_AgmFitBounds = /*@__PURE__*/ (() => {\n    /**\n     * Adds the given directive to the auto fit bounds feature when the value is true.\n     * To make it work with you custom AGM component, you also have to implement the {@link FitBoundsAccessor} abstract class.\n     * @example\n     * <agm-marker [agmFitBounds]=\"true\"></agm-marker>\n     */\n    let AgmFitBounds = class AgmFitBounds {\n        constructor(_fitBoundsAccessor, _fitBoundsService) {\n            this._fitBoundsAccessor = _fitBoundsAccessor;\n            this._fitBoundsService = _fitBoundsService;\n            /**\n             * If the value is true, the element gets added to the bounds of the map.\n             * Default: true.\n             */\n            this.agmFitBounds = true;\n            this._destroyed$ = new Subject[\"a\" /* Subject */]();\n            this._latestFitBoundsDetails = null;\n        }\n        /**\n         * @internal\n         */\n        ngOnChanges() {\n            this._updateBounds();\n        }\n        /**\n         * @internal\n         */\n        ngOnInit() {\n            this._fitBoundsAccessor\n                .getFitBoundsDetails$()\n                .pipe(Object(distinctUntilChanged[\"a\" /* distinctUntilChanged */])((x, y) => x.latLng.lat === y.latLng.lat && x.latLng.lng === y.latLng.lng), Object(takeUntil[\"a\" /* takeUntil */])(this._destroyed$))\n                .subscribe(details => this._updateBounds(details));\n        }\n        /*\n         Either the location changed, or visible status changed.\n         Possible state changes are\n         invisible -> visible\n         visible -> invisible\n         visible -> visible (new location)\n        */\n        _updateBounds(newFitBoundsDetails) {\n            // either visibility will change, or location, so remove the old one anyway\n            if (this._latestFitBoundsDetails) {\n                this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n                // don't set latestFitBoundsDetails to null, because we can toggle visibility from\n                // true -> false -> true, in which case we still need old value cached here\n            }\n            if (newFitBoundsDetails) {\n                this._latestFitBoundsDetails = newFitBoundsDetails;\n            }\n            if (!this._latestFitBoundsDetails) {\n                return;\n            }\n            if (this.agmFitBounds === true) {\n                this._fitBoundsService.addToBounds(this._latestFitBoundsDetails.latLng);\n            }\n        }\n        /**\n         * @internal\n         */\n        ngOnDestroy() {\n            this._destroyed$.next();\n            this._destroyed$.complete();\n            if (this._latestFitBoundsDetails !== null) {\n                this._fitBoundsService.removeFromBounds(this._latestFitBoundsDetails.latLng);\n            }\n        }\n    };\n    AgmFitBounds.ɵfac = function AgmFitBounds_Factory(t) { return new (t || AgmFitBounds)(core[\"Qb\" /* ɵɵdirectiveInject */](FitBoundsAccessor, 2), core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_FitBoundsService)); };\n    AgmFitBounds.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmFitBounds, selectors: [[\"\", \"agmFitBounds\", \"\"]], inputs: { agmFitBounds: \"agmFitBounds\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmFitBounds = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__param\"])(0, Object(core[\"K\" /* Self */])()),\n        Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [FitBoundsAccessor,\n            agm_core_FitBoundsService])\n    ], AgmFitBounds);\n    return AgmFitBounds;\n})();\nlet agm_core_MarkerManager = /*@__PURE__*/ (() => {\n    let MarkerManager = class MarkerManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._markers = new Map();\n        }\n        convertAnimation(uiAnim) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                if (uiAnim === null) {\n                    return null;\n                }\n                else {\n                    return this._mapsWrapper.getNativeMap().then(() => google.maps.Animation[uiAnim]);\n                }\n            });\n        }\n        deleteMarker(marker) {\n            const m = this._markers.get(marker);\n            if (m == null) {\n                // marker already deleted\n                return Promise.resolve();\n            }\n            return m.then((m) => {\n                return this._zone.run(() => {\n                    m.setMap(null);\n                    this._markers.delete(marker);\n                });\n            });\n        }\n        updateMarkerPosition(marker) {\n            return this._markers.get(marker).then((m) => m.setPosition({ lat: marker.latitude, lng: marker.longitude }));\n        }\n        updateTitle(marker) {\n            return this._markers.get(marker).then((m) => m.setTitle(marker.title));\n        }\n        updateLabel(marker) {\n            return this._markers.get(marker).then((m) => { m.setLabel(marker.label); });\n        }\n        updateDraggable(marker) {\n            return this._markers.get(marker).then((m) => m.setDraggable(marker.draggable));\n        }\n        updateIcon(marker) {\n            return this._markers.get(marker).then((m) => m.setIcon(marker.iconUrl));\n        }\n        updateOpacity(marker) {\n            return this._markers.get(marker).then((m) => m.setOpacity(marker.opacity));\n        }\n        updateVisible(marker) {\n            return this._markers.get(marker).then((m) => m.setVisible(marker.visible));\n        }\n        updateZIndex(marker) {\n            return this._markers.get(marker).then((m) => m.setZIndex(marker.zIndex));\n        }\n        updateClickable(marker) {\n            return this._markers.get(marker).then((m) => m.setClickable(marker.clickable));\n        }\n        updateAnimation(marker) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                const m = yield this._markers.get(marker);\n                m.setAnimation(yield this.convertAnimation(marker.animation));\n            });\n        }\n        addMarker(marker) {\n            const markerPromise = new Promise((resolve) => Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                return this._mapsWrapper.createMarker({\n                    position: { lat: marker.latitude, lng: marker.longitude },\n                    label: marker.label,\n                    draggable: marker.draggable,\n                    icon: marker.iconUrl,\n                    opacity: marker.opacity,\n                    visible: marker.visible,\n                    zIndex: marker.zIndex,\n                    title: marker.title,\n                    clickable: marker.clickable,\n                    animation: yield this.convertAnimation(marker.animation),\n                }).then(resolve);\n            }));\n            this._markers.set(marker, markerPromise);\n        }\n        getNativeMarker(marker) {\n            return this._markers.get(marker);\n        }\n        createEventObservable(eventName, marker) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._markers.get(marker).then((m) => {\n                    m.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n    };\n    MarkerManager.ɵfac = function MarkerManager_Factory(t) { return new (t || MarkerManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    MarkerManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: MarkerManager, factory: function (t) { return MarkerManager.ɵfac(t); } });\n    MarkerManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], MarkerManager);\n    return MarkerManager;\n})();\nlet agm_core_InfoWindowManager = /*@__PURE__*/ (() => {\n    let InfoWindowManager = class InfoWindowManager {\n        constructor(_mapsWrapper, _zone, _markerManager) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._markerManager = _markerManager;\n            this._infoWindows = new Map();\n        }\n        deleteInfoWindow(infoWindow) {\n            const iWindow = this._infoWindows.get(infoWindow);\n            if (iWindow == null) {\n                // info window already deleted\n                return Promise.resolve();\n            }\n            return iWindow.then((i) => {\n                return this._zone.run(() => {\n                    i.close();\n                    this._infoWindows.delete(infoWindow);\n                });\n            });\n        }\n        setPosition(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((i) => i.setPosition({\n                lat: infoWindow.latitude,\n                lng: infoWindow.longitude,\n            }));\n        }\n        setZIndex(infoWindow) {\n            return this._infoWindows.get(infoWindow)\n                .then((i) => i.setZIndex(infoWindow.zIndex));\n        }\n        open(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((w) => {\n                if (infoWindow.hostMarker != null) {\n                    return this._markerManager.getNativeMarker(infoWindow.hostMarker).then((marker) => {\n                        return this._mapsWrapper.getNativeMap().then((map) => w.open(map, marker));\n                    });\n                }\n                return this._mapsWrapper.getNativeMap().then((map) => w.open(map));\n            });\n        }\n        close(infoWindow) {\n            return this._infoWindows.get(infoWindow).then((w) => w.close());\n        }\n        setOptions(infoWindow, options) {\n            return this._infoWindows.get(infoWindow).then((i) => i.setOptions(options));\n        }\n        addInfoWindow(infoWindow) {\n            const options = {\n                content: infoWindow.content,\n                maxWidth: infoWindow.maxWidth,\n                zIndex: infoWindow.zIndex,\n                disableAutoPan: infoWindow.disableAutoPan,\n            };\n            if (typeof infoWindow.latitude === 'number' && typeof infoWindow.longitude === 'number') {\n                options.position = { lat: infoWindow.latitude, lng: infoWindow.longitude };\n            }\n            const infoWindowPromise = this._mapsWrapper.createInfoWindow(options);\n            this._infoWindows.set(infoWindow, infoWindowPromise);\n        }\n        /**\n         * Creates a Google Maps event listener for the given InfoWindow as an Observable\n         */\n        createEventObservable(eventName, infoWindow) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._infoWindows.get(infoWindow).then((i) => {\n                    i.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n    };\n    InfoWindowManager.ɵfac = function InfoWindowManager_Factory(t) { return new (t || InfoWindowManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */]), core[\"dc\" /* ɵɵinject */](agm_core_MarkerManager)); };\n    InfoWindowManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: InfoWindowManager, factory: function (t) { return InfoWindowManager.ɵfac(t); } });\n    InfoWindowManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */],\n            agm_core_MarkerManager])\n    ], InfoWindowManager);\n    return InfoWindowManager;\n})();\nvar AgmInfoWindow_1;\nlet infoWindowId = 0;\nlet agm_core_AgmInfoWindow = /*@__PURE__*/ (() => {\n    /**\n     * AgmInfoWindow renders a info window inside a {@link AgmMarker} or standalone.\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from '@angular/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  styles: [`\n     *    .agm-map-container {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *      <agm-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n     *        <agm-info-window [disableAutoPan]=\"true\">\n     *          Hi, this is the content of the <strong>info window</strong>\n     *        </agm-info-window>\n     *      </agm-marker>\n     *    </agm-map>\n     *  `\n     * })\n     * ```\n     */\n    let AgmInfoWindow = AgmInfoWindow_1 = class AgmInfoWindow {\n        constructor(_infoWindowManager, _el) {\n            this._infoWindowManager = _infoWindowManager;\n            this._el = _el;\n            /**\n             * Sets the open state for the InfoWindow. You can also call the open() and close() methods.\n             */\n            this.isOpen = false;\n            /**\n             * Emits an event when the info window is closed.\n             */\n            this.infoWindowClose = new core[\"n\" /* EventEmitter */]();\n            this._infoWindowAddedToManager = false;\n            this._id = (infoWindowId++).toString();\n        }\n        ngOnInit() {\n            this.content = this._el.nativeElement.querySelector('.agm-info-window-content');\n            this._infoWindowManager.addInfoWindow(this);\n            this._infoWindowAddedToManager = true;\n            this._updateOpenState();\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._infoWindowAddedToManager) {\n                return;\n            }\n            if ((changes['latitude'] || changes['longitude']) && typeof this.latitude === 'number' &&\n                typeof this.longitude === 'number') {\n                this._infoWindowManager.setPosition(this);\n            }\n            if (changes['zIndex']) {\n                this._infoWindowManager.setZIndex(this);\n            }\n            if (changes['isOpen']) {\n                this._updateOpenState();\n            }\n            this._setInfoWindowOptions(changes);\n        }\n        _registerEventListeners() {\n            this._infoWindowManager.createEventObservable('closeclick', this).subscribe(() => {\n                this.isOpen = false;\n                this.infoWindowClose.emit();\n            });\n        }\n        _updateOpenState() {\n            this.isOpen ? this.open() : this.close();\n        }\n        _setInfoWindowOptions(changes) {\n            let options = {};\n            let optionKeys = Object.keys(changes).filter(k => AgmInfoWindow_1._infoWindowOptionsInputs.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            this._infoWindowManager.setOptions(this, options);\n        }\n        /**\n         * Opens the info window.\n         */\n        open() { return this._infoWindowManager.open(this); }\n        /**\n         * Closes the info window.\n         */\n        close() {\n            return this._infoWindowManager.close(this).then(() => { this.infoWindowClose.emit(); });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return 'AgmInfoWindow-' + this._id.toString(); }\n        /** @internal */\n        ngOnDestroy() { this._infoWindowManager.deleteInfoWindow(this); }\n    };\n    AgmInfoWindow.ɵfac = function AgmInfoWindow_Factory(t) { return new (t || AgmInfoWindow)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_InfoWindowManager), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */])); };\n    AgmInfoWindow.ɵcmp = core[\"Kb\" /* ɵɵdefineComponent */]({ type: AgmInfoWindow, selectors: [[\"agm-info-window\"]], inputs: { isOpen: \"isOpen\", latitude: \"latitude\", longitude: \"longitude\", disableAutoPan: \"disableAutoPan\", zIndex: \"zIndex\", maxWidth: \"maxWidth\" }, outputs: { infoWindowClose: \"infoWindowClose\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[1, \"agm-info-window-content\"]], template: function AgmInfoWindow_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 0);\n                core[\"nc\" /* ɵɵprojection */](1);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n        }, encapsulation: 2 });\n    AgmInfoWindow._infoWindowOptionsInputs = ['disableAutoPan', 'maxWidth'];\n    AgmInfoWindow = AgmInfoWindow_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_InfoWindowManager, core[\"l\" /* ElementRef */]])\n    ], AgmInfoWindow);\n    return AgmInfoWindow;\n})();\nlet agm_core_KmlLayerManager = /*@__PURE__*/ (() => {\n    /**\n     * Manages all KML Layers for a Google Map instance.\n     */\n    let KmlLayerManager = class KmlLayerManager {\n        constructor(_wrapper, _zone) {\n            this._wrapper = _wrapper;\n            this._zone = _zone;\n            this._layers = new Map();\n        }\n        /**\n         * Adds a new KML Layer to the map.\n         */\n        addKmlLayer(layer) {\n            const newLayer = this._wrapper.getNativeMap().then(m => {\n                return new google.maps.KmlLayer({\n                    clickable: layer.clickable,\n                    map: m,\n                    preserveViewport: layer.preserveViewport,\n                    screenOverlays: layer.screenOverlays,\n                    suppressInfoWindows: layer.suppressInfoWindows,\n                    url: layer.url,\n                    zIndex: layer.zIndex,\n                });\n            });\n            this._layers.set(layer, newLayer);\n        }\n        setOptions(layer, options) {\n            this._layers.get(layer).then(l => l.setOptions(options));\n        }\n        deleteKmlLayer(layer) {\n            this._layers.get(layer).then(l => {\n                l.setMap(null);\n                this._layers.delete(layer);\n            });\n        }\n        /**\n         * Creates a Google Maps event listener for the given KmlLayer as an Observable\n         */\n        createEventObservable(eventName, layer) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._layers.get(layer).then((m) => {\n                    m.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n    };\n    KmlLayerManager.ɵfac = function KmlLayerManager_Factory(t) { return new (t || KmlLayerManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    KmlLayerManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: KmlLayerManager, factory: function (t) { return KmlLayerManager.ɵfac(t); } });\n    KmlLayerManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], KmlLayerManager);\n    return KmlLayerManager;\n})();\nvar AgmKmlLayer_1;\nlet layerId$2 = 0;\nlet agm_core_AgmKmlLayer = /*@__PURE__*/ (() => {\n    let AgmKmlLayer = AgmKmlLayer_1 = class AgmKmlLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$2++).toString();\n            this._subscriptions = [];\n            /**\n             * If true, the layer receives mouse events. Default value is true.\n             */\n            this.clickable = true;\n            /**\n             * By default, the input map is centered and zoomed to the bounding box of the contents of the\n             * layer.\n             * If this option is set to true, the viewport is left unchanged, unless the map's center and zoom\n             * were never set.\n             */\n            this.preserveViewport = false;\n            /**\n             * Whether to render the screen overlays. Default true.\n             */\n            this.screenOverlays = true;\n            /**\n             * Suppress the rendering of info windows when layer features are clicked.\n             */\n            this.suppressInfoWindows = false;\n            /**\n             * The URL of the KML document to display.\n             */\n            this.url = null;\n            /**\n             * The z-index of the layer.\n             */\n            this.zIndex = null;\n            /**\n             * This event is fired when a feature in the layer is clicked.\n             */\n            this.layerClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the KML layers default viewport has changed.\n             */\n            this.defaultViewportChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the KML layer has finished loading.\n             * At this point it is safe to read the status property to determine if the layer loaded\n             * successfully.\n             */\n            this.statusChange = new core[\"n\" /* EventEmitter */]();\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addKmlLayer(this);\n            this._addedToManager = true;\n            this._addEventListeners();\n        }\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            this._updatePolygonOptions(changes);\n        }\n        _updatePolygonOptions(changes) {\n            const options = Object.keys(changes)\n                .filter(k => AgmKmlLayer_1._kmlLayerOptions.indexOf(k) !== -1)\n                .reduce((obj, k) => {\n                obj[k] = changes[k].currentValue;\n                return obj;\n            }, {});\n            if (Object.keys(options).length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _addEventListeners() {\n            const listeners = [\n                { name: 'click', handler: (ev) => this.layerClick.emit(ev) },\n                { name: 'defaultviewport_changed', handler: () => this.defaultViewportChange.emit() },\n                { name: 'status_changed', handler: () => this.statusChange.emit() },\n            ];\n            listeners.forEach((obj) => {\n                const os = this._manager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmKmlLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteKmlLayer(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach(s => s.unsubscribe());\n        }\n    };\n    AgmKmlLayer.ɵfac = function AgmKmlLayer_Factory(t) { return new (t || AgmKmlLayer)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_KmlLayerManager)); };\n    AgmKmlLayer.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmKmlLayer, selectors: [[\"agm-kml-layer\"]], inputs: { clickable: \"clickable\", preserveViewport: \"preserveViewport\", screenOverlays: \"screenOverlays\", suppressInfoWindows: \"suppressInfoWindows\", url: \"url\", zIndex: \"zIndex\" }, outputs: { layerClick: \"layerClick\", defaultViewportChange: \"defaultViewportChange\", statusChange: \"statusChange\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmKmlLayer._kmlLayerOptions = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex'];\n    AgmKmlLayer = AgmKmlLayer_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_KmlLayerManager])\n    ], AgmKmlLayer);\n    return AgmKmlLayer;\n})();\nfunction createMVCEventObservable(array) {\n    const eventNames = ['insert_at', 'remove_at', 'set_at'];\n    return fromEventPattern((handler) => eventNames.map(evName => array.addListener(evName, (index, previous) => handler.apply(array, [{ 'newArr': array.getArray(), evName, index, previous }]))), (_handler, evListeners) => evListeners.forEach(evListener => evListener.remove()));\n}\nclass MvcArrayMock {\n    constructor() {\n        this.vals = [];\n        this.listeners = {\n            'remove_at': [],\n            'insert_at': [],\n            'set_at': [],\n        };\n    }\n    clear() {\n        for (let i = this.vals.length - 1; i >= 0; i--) {\n            this.removeAt(i);\n        }\n    }\n    getArray() {\n        return [...this.vals];\n    }\n    getAt(i) {\n        return this.vals[i];\n    }\n    getLength() {\n        return this.vals.length;\n    }\n    insertAt(i, elem) {\n        this.vals.splice(i, 0, elem);\n        this.listeners.insert_at.map(listener => listener(i));\n    }\n    pop() {\n        const deleted = this.vals.pop();\n        this.listeners.remove_at.map(listener => listener(this.vals.length, deleted));\n        return deleted;\n    }\n    push(elem) {\n        this.vals.push(elem);\n        this.listeners.insert_at.map(listener => listener(this.vals.length - 1));\n        return this.vals.length;\n    }\n    removeAt(i) {\n        const deleted = this.vals.splice(i, 1)[0];\n        this.listeners.remove_at.map(listener => listener(i, deleted));\n        return deleted;\n    }\n    setAt(i, elem) {\n        const deleted = this.vals[i];\n        this.vals[i] = elem;\n        this.listeners.set_at.map(listener => listener(i, deleted));\n    }\n    forEach(callback) {\n        this.vals.forEach(callback);\n    }\n    addListener(eventName, handler) {\n        const listenerArr = this.listeners[eventName];\n        listenerArr.push(handler);\n        return {\n            remove: () => {\n                listenerArr.splice(listenerArr.indexOf(handler), 1);\n            },\n        };\n    }\n}\nlet agm_core_PolygonManager = /*@__PURE__*/ (() => {\n    let PolygonManager = class PolygonManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._polygons = new Map();\n        }\n        addPolygon(path) {\n            const polygonPromise = this._mapsWrapper.createPolygon({\n                clickable: path.clickable,\n                draggable: path.draggable,\n                editable: path.editable,\n                fillColor: path.fillColor,\n                fillOpacity: path.fillOpacity,\n                geodesic: path.geodesic,\n                paths: path.paths,\n                strokeColor: path.strokeColor,\n                strokeOpacity: path.strokeOpacity,\n                strokeWeight: path.strokeWeight,\n                visible: path.visible,\n                zIndex: path.zIndex,\n            });\n            this._polygons.set(path, polygonPromise);\n        }\n        updatePolygon(polygon) {\n            const m = this._polygons.get(polygon);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => this._zone.run(() => { l.setPaths(polygon.paths); }));\n        }\n        setPolygonOptions(path, options) {\n            return this._polygons.get(path).then((l) => { l.setOptions(options); });\n        }\n        deletePolygon(paths) {\n            const m = this._polygons.get(paths);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => {\n                return this._zone.run(() => {\n                    l.setMap(null);\n                    this._polygons.delete(paths);\n                });\n            });\n        }\n        getPath(polygon) {\n            return this._polygons.get(polygon)\n                .then((polygon) => polygon.getPath().getArray());\n        }\n        getPaths(polygon) {\n            return this._polygons.get(polygon)\n                .then((polygon) => polygon.getPaths().getArray().map((p) => p.getArray()));\n        }\n        createEventObservable(eventName, path) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._polygons.get(path).then((l) => {\n                    l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        createPathEventObservable(agmPolygon) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                const polygon = yield this._polygons.get(agmPolygon);\n                const paths = polygon.getPaths();\n                const pathsChanges$ = createMVCEventObservable(paths);\n                return pathsChanges$.pipe(Object(startWith[\"a\" /* startWith */])({ newArr: paths.getArray() }), // in order to subscribe to them all\n                Object(switchMap[\"a\" /* switchMap */])(parentMVEvent => Object(merge[\"a\" /* merge */])(... // rest parameter\n                parentMVEvent.newArr.map((chMVC, index) => createMVCEventObservable(chMVC)\n                    .pipe(Object(map[\"a\" /* map */])(chMVCEvent => ({ parentMVEvent, chMVCEvent, pathIndex: index })))))\n                    .pipe(Object(startWith[\"a\" /* startWith */])({ parentMVEvent, chMVCEvent: null, pathIndex: null }))), // start the merged ob with an event signinifing change to parent\n                Object(skip[\"a\" /* skip */])(1), // skip the manually added event\n                Object(map[\"a\" /* map */])(({ parentMVEvent, chMVCEvent, pathIndex }) => {\n                    let retVal;\n                    if (!chMVCEvent) {\n                        retVal = {\n                            newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n                            eventName: parentMVEvent.evName,\n                            index: parentMVEvent.index,\n                        };\n                        if (parentMVEvent.previous) {\n                            retVal.previous = parentMVEvent.previous.getArray();\n                        }\n                    }\n                    else {\n                        retVal = {\n                            newArr: parentMVEvent.newArr.map(subArr => subArr.getArray().map(latLng => latLng.toJSON())),\n                            pathIndex,\n                            eventName: chMVCEvent.evName,\n                            index: chMVCEvent.index,\n                        };\n                        if (chMVCEvent.previous) {\n                            retVal.previous = chMVCEvent.previous;\n                        }\n                    }\n                    return retVal;\n                }));\n            });\n        }\n    };\n    PolygonManager.ɵfac = function PolygonManager_Factory(t) { return new (t || PolygonManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    PolygonManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: PolygonManager, factory: function (t) { return PolygonManager.ɵfac(t); } });\n    PolygonManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], PolygonManager);\n    return PolygonManager;\n})();\nvar PolylineManager_1;\nlet agm_core_PolylineManager = /*@__PURE__*/ (() => {\n    let PolylineManager = PolylineManager_1 = class PolylineManager {\n        constructor(_mapsWrapper, _zone) {\n            this._mapsWrapper = _mapsWrapper;\n            this._zone = _zone;\n            this._polylines = new Map();\n        }\n        static _convertPoints(line) {\n            const path = line._getPoints().map((point) => {\n                return { lat: point.latitude, lng: point.longitude };\n            });\n            return path;\n        }\n        static _convertPath(path) {\n            const symbolPath = google.maps.SymbolPath[path];\n            if (typeof symbolPath === 'number') {\n                return symbolPath;\n            }\n            else {\n                return path;\n            }\n        }\n        static _convertIcons(line) {\n            const icons = line._getIcons().map(agmIcon => ({\n                fixedRotation: agmIcon.fixedRotation,\n                offset: agmIcon.offset,\n                repeat: agmIcon.repeat,\n                icon: {\n                    anchor: new google.maps.Point(agmIcon.anchorX, agmIcon.anchorY),\n                    fillColor: agmIcon.fillColor,\n                    fillOpacity: agmIcon.fillOpacity,\n                    path: PolylineManager_1._convertPath(agmIcon.path),\n                    rotation: agmIcon.rotation,\n                    scale: agmIcon.scale,\n                    strokeColor: agmIcon.strokeColor,\n                    strokeOpacity: agmIcon.strokeOpacity,\n                    strokeWeight: agmIcon.strokeWeight,\n                },\n            }));\n            // prune undefineds;\n            icons.forEach(icon => {\n                Object.entries(icon).forEach(([key, val]) => {\n                    if (typeof val === 'undefined') {\n                        delete icon[key];\n                    }\n                });\n                if (typeof icon.icon.anchor.x === 'undefined' ||\n                    typeof icon.icon.anchor.y === 'undefined') {\n                    delete icon.icon.anchor;\n                }\n            });\n            return icons;\n        }\n        addPolyline(line) {\n            const polylinePromise = this._mapsWrapper.getNativeMap()\n                .then(() => [PolylineManager_1._convertPoints(line),\n                PolylineManager_1._convertIcons(line)])\n                .then(([path, icons]) => this._mapsWrapper.createPolyline({\n                clickable: line.clickable,\n                draggable: line.draggable,\n                editable: line.editable,\n                geodesic: line.geodesic,\n                strokeColor: line.strokeColor,\n                strokeOpacity: line.strokeOpacity,\n                strokeWeight: line.strokeWeight,\n                visible: line.visible,\n                zIndex: line.zIndex,\n                path: path,\n                icons: icons,\n            }));\n            this._polylines.set(line, polylinePromise);\n        }\n        updatePolylinePoints(line) {\n            const path = PolylineManager_1._convertPoints(line);\n            const m = this._polylines.get(line);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => { return this._zone.run(() => { l.setPath(path); }); });\n        }\n        updateIconSequences(line) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                yield this._mapsWrapper.getNativeMap();\n                const icons = PolylineManager_1._convertIcons(line);\n                const m = this._polylines.get(line);\n                if (m == null) {\n                    return;\n                }\n                return m.then(l => this._zone.run(() => l.setOptions({ icons: icons })));\n            });\n        }\n        setPolylineOptions(line, options) {\n            return this._polylines.get(line).then((l) => { l.setOptions(options); });\n        }\n        deletePolyline(line) {\n            const m = this._polylines.get(line);\n            if (m == null) {\n                return Promise.resolve();\n            }\n            return m.then((l) => {\n                return this._zone.run(() => {\n                    l.setMap(null);\n                    this._polylines.delete(line);\n                });\n            });\n        }\n        getMVCPath(agmPolyline) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                const polyline = yield this._polylines.get(agmPolyline);\n                return polyline.getPath();\n            });\n        }\n        getPath(agmPolyline) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                return (yield this.getMVCPath(agmPolyline)).getArray();\n            });\n        }\n        createEventObservable(eventName, line) {\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                this._polylines.get(line).then((l) => {\n                    l.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n            });\n        }\n        createPathEventObservable(line) {\n            return Object(tslib_es6[\"__awaiter\"])(this, void 0, void 0, function* () {\n                const mvcPath = yield this.getMVCPath(line);\n                return createMVCEventObservable(mvcPath);\n            });\n        }\n    };\n    PolylineManager.ɵfac = function PolylineManager_Factory(t) { return new (t || PolylineManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    PolylineManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: PolylineManager, factory: function (t) { return PolylineManager.ɵfac(t); } });\n    PolylineManager = PolylineManager_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], PolylineManager);\n    return PolylineManager;\n})();\nlet agm_core_RectangleManager = /*@__PURE__*/ (() => {\n    let RectangleManager = class RectangleManager {\n        constructor(_apiWrapper, _zone) {\n            this._apiWrapper = _apiWrapper;\n            this._zone = _zone;\n            this._rectangles = new Map();\n        }\n        addRectangle(rectangle) {\n            this._rectangles.set(rectangle, this._apiWrapper.createRectangle({\n                bounds: {\n                    north: rectangle.north,\n                    east: rectangle.east,\n                    south: rectangle.south,\n                    west: rectangle.west,\n                },\n                clickable: rectangle.clickable,\n                draggable: rectangle.draggable,\n                editable: rectangle.editable,\n                fillColor: rectangle.fillColor,\n                fillOpacity: rectangle.fillOpacity,\n                strokeColor: rectangle.strokeColor,\n                strokeOpacity: rectangle.strokeOpacity,\n                strokePosition: rectangle.strokePosition,\n                strokeWeight: rectangle.strokeWeight,\n                visible: rectangle.visible,\n                zIndex: rectangle.zIndex,\n            }));\n        }\n        /**\n         * Removes the given rectangle from the map.\n         */\n        removeRectangle(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                r.setMap(null);\n                this._rectangles.delete(rectangle);\n            });\n        }\n        setOptions(rectangle, options) {\n            return this._rectangles.get(rectangle).then((r) => r.setOptions(options));\n        }\n        getBounds(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => r.getBounds());\n        }\n        setBounds(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setBounds({\n                    north: rectangle.north,\n                    east: rectangle.east,\n                    south: rectangle.south,\n                    west: rectangle.west,\n                });\n            });\n        }\n        setEditable(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setEditable(rectangle.editable);\n            });\n        }\n        setDraggable(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setDraggable(rectangle.draggable);\n            });\n        }\n        setVisible(rectangle) {\n            return this._rectangles.get(rectangle).then((r) => {\n                return r.setVisible(rectangle.visible);\n            });\n        }\n        createEventObservable(eventName, rectangle) {\n            return Observable[\"a\" /* Observable */].create((observer) => {\n                let listener = null;\n                this._rectangles.get(rectangle).then((r) => {\n                    listener = r.addListener(eventName, (e) => this._zone.run(() => observer.next(e)));\n                });\n                return () => {\n                    if (listener !== null) {\n                        listener.remove();\n                    }\n                };\n            });\n        }\n    };\n    RectangleManager.ɵfac = function RectangleManager_Factory(t) { return new (t || RectangleManager)(core[\"dc\" /* ɵɵinject */](agm_core_GoogleMapsAPIWrapper), core[\"dc\" /* ɵɵinject */](core[\"z\" /* NgZone */])); };\n    RectangleManager.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: RectangleManager, factory: function (t) { return RectangleManager.ɵfac(t); } });\n    RectangleManager = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_GoogleMapsAPIWrapper, core[\"z\" /* NgZone */]])\n    ], RectangleManager);\n    return RectangleManager;\n})();\nvar AgmMap_1;\nlet agm_core_AgmMap = /*@__PURE__*/ (() => {\n    /**\n     * AgmMap renders a Google Map.\n     * **Important note**: To be able see a map in the browser, you have to define a height for the\n     * element `agm-map`.\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from '@angular/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  styles: [`\n     *    agm-map {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *    </agm-map>\n     *  `\n     * })\n     * ```\n     */\n    let AgmMap = AgmMap_1 = class AgmMap {\n        constructor(_elem, _mapsWrapper, _platformId, _fitBoundsService, _zone) {\n            this._elem = _elem;\n            this._mapsWrapper = _mapsWrapper;\n            this._platformId = _platformId;\n            this._fitBoundsService = _fitBoundsService;\n            this._zone = _zone;\n            /**\n             * The longitude that defines the center of the map.\n             */\n            this.longitude = 0;\n            /**\n             * The latitude that defines the center of the map.\n             */\n            this.latitude = 0;\n            /**\n             * The zoom level of the map. The default zoom level is 8.\n             */\n            this.zoom = 8;\n            /**\n             * Enables/disables if map is draggable.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = true;\n            /**\n             * Enables/disables zoom and center on double click. Enabled by default.\n             */\n            this.disableDoubleClickZoom = false;\n            /**\n             * Enables/disables all default UI of the Google map. Please note: When the map is created, this\n             * value cannot get updated.\n             */\n            this.disableDefaultUI = false;\n            /**\n             * If false, disables scrollwheel zooming on the map. The scrollwheel is enabled by default.\n             */\n            this.scrollwheel = true;\n            /**\n             * If false, prevents the map from being controlled by the keyboard. Keyboard shortcuts are\n             * enabled by default.\n             */\n            this.keyboardShortcuts = true;\n            /**\n             * Styles to apply to each of the default map types. Note that for Satellite/Hybrid and Terrain\n             * modes, these styles will only apply to labels and geometry.\n             */\n            this.styles = [];\n            /**\n             * When true and the latitude and/or longitude values changes, the Google Maps panTo method is\n             * used to\n             * center the map. See: https://developers.google.com/maps/documentation/javascript/reference#Map\n             */\n            this.usePanning = false;\n            /**\n             * Sets the viewport to contain the given bounds.\n             * If this option to `true`, the bounds get automatically computed from all elements that use the {@link AgmFitBounds} directive.\n             */\n            this.fitBounds = false;\n            /**\n             * The initial enabled/disabled state of the Scale control. This is disabled by default.\n             */\n            this.scaleControl = false;\n            /**\n             * The initial enabled/disabled state of the Map type control.\n             */\n            this.mapTypeControl = false;\n            /**\n             * The initial enabled/disabled state of the Pan control.\n             */\n            this.panControl = false;\n            /**\n             * The initial enabled/disabled state of the Rotate control.\n             */\n            this.rotateControl = false;\n            /**\n             * The initial enabled/disabled state of the Fullscreen control.\n             */\n            this.fullscreenControl = false;\n            /**\n             * The map mapTypeId. Defaults to 'roadmap'.\n             */\n            this.mapTypeId = 'roadmap';\n            /**\n             * When false, map icons are not clickable. A map icon represents a point of interest,\n             * also known as a POI. By default map icons are clickable.\n             */\n            this.clickableIcons = true;\n            /**\n             * A map icon represents a point of interest, also known as a POI.\n             * When map icons are clickable by default, an info window is displayed.\n             * When this property is set to false, the info window will not be shown but the click event\n             * will still fire\n             */\n            this.showDefaultInfoWindow = true;\n            /**\n             * This setting controls how gestures on the map are handled.\n             * Allowed values:\n             * - 'cooperative' (Two-finger touch gestures pan and zoom the map. One-finger touch gestures are not handled by the map.)\n             * - 'greedy'      (All touch gestures pan or zoom the map.)\n             * - 'none'        (The map cannot be panned or zoomed by user gestures.)\n             * - 'auto'        [default] (Gesture handling is either cooperative or greedy, depending on whether the page is scrollable or not.\n             */\n            this.gestureHandling = 'auto';\n            /**\n             * Controls the automatic switching behavior for the angle of incidence of\n             * the map. The only allowed values are 0 and 45. The value 0 causes the map\n             * to always use a 0° overhead view regardless of the zoom level and\n             * viewport. The value 45 causes the tilt angle to automatically switch to\n             * 45 whenever 45° imagery is available for the current zoom level and\n             * viewport, and switch back to 0 whenever 45° imagery is not available\n             * (this is the default behavior). 45° imagery is only available for\n             * satellite and hybrid map types, within some locations, and at some zoom\n             * levels. Note: getTilt returns the current tilt angle, not the value\n             * specified by this option. Because getTilt and this option refer to\n             * different things, do not bind() the tilt property; doing so may yield\n             * unpredictable effects. (Default of AGM is 0 (disabled). Enable it with value 45.)\n             */\n            this.tilt = 0;\n            this._observableSubscriptions = [];\n            /**\n             * This event emitter gets emitted when the user clicks on the map (but not when they click on a\n             * marker or infoWindow).\n             */\n            this.mapClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user right-clicks on the map (but not when they click\n             * on a marker or infoWindow).\n             */\n            this.mapRightClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user double-clicks on the map (but not when they click\n             * on a marker or infoWindow).\n             */\n            this.mapDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter is fired when the map center changes.\n             */\n            this.centerChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the viewport bounds have changed.\n             */\n            this.boundsChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the mapTypeId property changes.\n             */\n            this.mapTypeIdChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the map becomes idle after panning or zooming.\n             */\n            this.idle = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the zoom level has changed.\n             */\n            this.zoomChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the google map is fully initialized.\n             * You get the google.maps.Map instance as a result of this EventEmitter.\n             */\n            this.mapReady = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the visible tiles have finished loading.\n             */\n            this.tilesLoaded = new core[\"n\" /* EventEmitter */]();\n        }\n        /** @internal */\n        ngOnInit() {\n            if (Object(common[\"A\" /* isPlatformServer */])(this._platformId)) {\n                // The code is running on the server, do nothing\n                return;\n            }\n            // todo: this should be solved with a new component and a viewChild decorator\n            const container = this._elem.nativeElement.querySelector('.agm-map-container-inner');\n            this._initMapInstance(container);\n        }\n        _initMapInstance(el) {\n            this._mapsWrapper.createMap(el, {\n                center: { lat: this.latitude || 0, lng: this.longitude || 0 },\n                zoom: this.zoom,\n                minZoom: this.minZoom,\n                maxZoom: this.maxZoom,\n                controlSize: this.controlSize,\n                disableDefaultUI: this.disableDefaultUI,\n                disableDoubleClickZoom: this.disableDoubleClickZoom,\n                scrollwheel: this.scrollwheel,\n                backgroundColor: this.backgroundColor,\n                draggable: this.draggable,\n                draggableCursor: this.draggableCursor,\n                draggingCursor: this.draggingCursor,\n                keyboardShortcuts: this.keyboardShortcuts,\n                styles: this.styles,\n                zoomControl: this.zoomControl,\n                zoomControlOptions: this.zoomControlOptions,\n                streetViewControl: this.streetViewControl,\n                streetViewControlOptions: this.streetViewControlOptions,\n                scaleControl: this.scaleControl,\n                scaleControlOptions: this.scaleControlOptions,\n                mapTypeControl: this.mapTypeControl,\n                mapTypeControlOptions: this.mapTypeControlOptions,\n                panControl: this.panControl,\n                panControlOptions: this.panControlOptions,\n                rotateControl: this.rotateControl,\n                rotateControlOptions: this.rotateControlOptions,\n                fullscreenControl: this.fullscreenControl,\n                fullscreenControlOptions: this.fullscreenControlOptions,\n                mapTypeId: this.mapTypeId,\n                clickableIcons: this.clickableIcons,\n                gestureHandling: this.gestureHandling,\n                tilt: this.tilt,\n                restriction: this.restriction,\n            })\n                .then(() => this._mapsWrapper.getNativeMap())\n                .then(map => this.mapReady.emit(map));\n            // register event listeners\n            this._handleMapCenterChange();\n            this._handleMapZoomChange();\n            this._handleMapMouseEvents();\n            this._handleBoundsChange();\n            this._handleMapTypeIdChange();\n            this._handleTilesLoadedEvent();\n            this._handleIdleEvent();\n        }\n        /** @internal */\n        ngOnDestroy() {\n            // unsubscribe all registered observable subscriptions\n            this._observableSubscriptions.forEach((s) => s.unsubscribe());\n            // remove all listeners from the map instance\n            this._mapsWrapper.clearInstanceListeners();\n            if (this._fitBoundsSubscription) {\n                this._fitBoundsSubscription.unsubscribe();\n            }\n        }\n        /* @internal */\n        ngOnChanges(changes) {\n            this._updateMapOptionsChanges(changes);\n            this._updatePosition(changes);\n        }\n        _updateMapOptionsChanges(changes) {\n            let options = {};\n            let optionKeys = Object.keys(changes).filter(k => AgmMap_1._mapOptionsAttributes.indexOf(k) !== -1);\n            optionKeys.forEach((k) => { options[k] = changes[k].currentValue; });\n            this._mapsWrapper.setMapOptions(options);\n        }\n        /**\n         * Triggers a resize event on the google map instance.\n         * When recenter is true, the of the google map gets called with the current lat/lng values or fitBounds value to recenter the map.\n         * Returns a promise that gets resolved after the event was triggered.\n         */\n        triggerResize(recenter = true) {\n            // Note: When we would trigger the resize event and show the map in the same turn (which is a\n            // common case for triggering a resize event), then the resize event would not\n            // work (to show the map), so we trigger the event in a timeout.\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    return this._mapsWrapper.triggerMapEvent('resize').then(() => {\n                        if (recenter) {\n                            this.fitBounds != null ? this._fitBounds() : this._setCenter();\n                        }\n                        resolve();\n                    });\n                });\n            });\n        }\n        _updatePosition(changes) {\n            if (changes['latitude'] == null && changes['longitude'] == null &&\n                !changes['fitBounds']) {\n                // no position update needed\n                return;\n            }\n            // we prefer fitBounds in changes\n            if ('fitBounds' in changes) {\n                this._fitBounds();\n                return;\n            }\n            if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n                return;\n            }\n            this._setCenter();\n        }\n        _setCenter() {\n            let newCenter = {\n                lat: this.latitude,\n                lng: this.longitude,\n            };\n            if (this.usePanning) {\n                this._mapsWrapper.panTo(newCenter);\n            }\n            else {\n                this._mapsWrapper.setCenter(newCenter);\n            }\n        }\n        _fitBounds() {\n            switch (this.fitBounds) {\n                case true:\n                    this._subscribeToFitBoundsUpdates();\n                    break;\n                case false:\n                    if (this._fitBoundsSubscription) {\n                        this._fitBoundsSubscription.unsubscribe();\n                    }\n                    break;\n                default:\n                    this._updateBounds(this.fitBounds, this.fitBoundsPadding);\n            }\n        }\n        _subscribeToFitBoundsUpdates() {\n            this._zone.runOutsideAngular(() => {\n                this._fitBoundsSubscription = this._fitBoundsService.getBounds$().subscribe(b => {\n                    this._zone.run(() => this._updateBounds(b, this.fitBoundsPadding));\n                });\n            });\n        }\n        _updateBounds(bounds, padding) {\n            if (!bounds) {\n                return;\n            }\n            if (this._isLatLngBoundsLiteral(bounds) && typeof google !== 'undefined' && google && google.maps && google.maps.LatLngBounds) {\n                const newBounds = new google.maps.LatLngBounds();\n                newBounds.union(bounds);\n                bounds = newBounds;\n            }\n            if (this.usePanning) {\n                this._mapsWrapper.panToBounds(bounds, padding);\n                return;\n            }\n            this._mapsWrapper.fitBounds(bounds, padding);\n        }\n        _isLatLngBoundsLiteral(bounds) {\n            return bounds != null && bounds.extend === undefined;\n        }\n        _handleMapCenterChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('center_changed').subscribe(() => {\n                this._mapsWrapper.getCenter().then((center) => {\n                    this.latitude = center.lat();\n                    this.longitude = center.lng();\n                    this.centerChange.emit({ lat: this.latitude, lng: this.longitude });\n                });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleBoundsChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('bounds_changed').subscribe(() => {\n                this._mapsWrapper.getBounds().then((bounds) => { this.boundsChange.emit(bounds); });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapTypeIdChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('maptypeid_changed').subscribe(() => {\n                this._mapsWrapper.getMapTypeId().then((mapTypeId) => { this.mapTypeIdChange.emit(mapTypeId); });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapZoomChange() {\n            const s = this._mapsWrapper.subscribeToMapEvent('zoom_changed').subscribe(() => {\n                this._mapsWrapper.getZoom().then((z) => {\n                    this.zoom = z;\n                    this.zoomChange.emit(z);\n                });\n            });\n            this._observableSubscriptions.push(s);\n        }\n        _handleIdleEvent() {\n            const s = this._mapsWrapper.subscribeToMapEvent('idle').subscribe(() => { this.idle.emit(void 0); });\n            this._observableSubscriptions.push(s);\n        }\n        _handleTilesLoadedEvent() {\n            const s = this._mapsWrapper.subscribeToMapEvent('tilesloaded').subscribe(() => this.tilesLoaded.emit(void 0));\n            this._observableSubscriptions.push(s);\n        }\n        _handleMapMouseEvents() {\n            const events = [\n                { name: 'click', emitter: this.mapClick },\n                { name: 'rightclick', emitter: this.mapRightClick },\n                { name: 'dblclick', emitter: this.mapDblClick },\n            ];\n            events.forEach((e) => {\n                const s = this._mapsWrapper.subscribeToMapEvent(e.name).subscribe((event) => {\n                    let value = {\n                        coords: {\n                            lat: event.latLng.lat(),\n                            lng: event.latLng.lng(),\n                        },\n                        placeId: event.placeId,\n                    };\n                    // the placeId will be undefined in case the event was not an IconMouseEvent (google types)\n                    if (value.placeId && !this.showDefaultInfoWindow) {\n                        event.stop();\n                    }\n                    e.emitter.emit(value);\n                });\n                this._observableSubscriptions.push(s);\n            });\n        }\n    };\n    AgmMap.ɵfac = function AgmMap_Factory(t) { return new (t || AgmMap)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"l\" /* ElementRef */]), core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_GoogleMapsAPIWrapper), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* PLATFORM_ID */]), core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_FitBoundsService), core[\"Qb\" /* ɵɵdirectiveInject */](core[\"z\" /* NgZone */])); };\n    AgmMap.ɵcmp = core[\"Kb\" /* ɵɵdefineComponent */]({ type: AgmMap, selectors: [[\"agm-map\"]], hostVars: 2, hostBindings: function AgmMap_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Ib\" /* ɵɵclassProp */](\"sebm-google-map-container\", true);\n            }\n        }, inputs: { longitude: \"longitude\", latitude: \"latitude\", zoom: \"zoom\", draggable: [\"mapDraggable\", \"draggable\"], disableDoubleClickZoom: \"disableDoubleClickZoom\", disableDefaultUI: \"disableDefaultUI\", scrollwheel: \"scrollwheel\", keyboardShortcuts: \"keyboardShortcuts\", styles: \"styles\", usePanning: \"usePanning\", fitBounds: \"fitBounds\", scaleControl: \"scaleControl\", mapTypeControl: \"mapTypeControl\", panControl: \"panControl\", rotateControl: \"rotateControl\", fullscreenControl: \"fullscreenControl\", mapTypeId: \"mapTypeId\", clickableIcons: \"clickableIcons\", showDefaultInfoWindow: \"showDefaultInfoWindow\", gestureHandling: \"gestureHandling\", tilt: \"tilt\", minZoom: \"minZoom\", maxZoom: \"maxZoom\", controlSize: \"controlSize\", backgroundColor: \"backgroundColor\", draggableCursor: \"draggableCursor\", draggingCursor: \"draggingCursor\", zoomControl: \"zoomControl\", zoomControlOptions: \"zoomControlOptions\", streetViewControl: \"streetViewControl\", streetViewControlOptions: \"streetViewControlOptions\", fitBoundsPadding: \"fitBoundsPadding\", scaleControlOptions: \"scaleControlOptions\", mapTypeControlOptions: \"mapTypeControlOptions\", panControlOptions: \"panControlOptions\", rotateControlOptions: \"rotateControlOptions\", fullscreenControlOptions: \"fullscreenControlOptions\", restriction: \"restriction\" }, outputs: { mapClick: \"mapClick\", mapRightClick: \"mapRightClick\", mapDblClick: \"mapDblClick\", centerChange: \"centerChange\", boundsChange: \"boundsChange\", mapTypeIdChange: \"mapTypeIdChange\", idle: \"idle\", zoomChange: \"zoomChange\", mapReady: \"mapReady\", tilesLoaded: \"tilesLoaded\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                agm_core_CircleManager,\n                agm_core_DataLayerManager,\n                agm_core_DataLayerManager,\n                agm_core_FitBoundsService,\n                agm_core_GoogleMapsAPIWrapper,\n                agm_core_InfoWindowManager,\n                agm_core_KmlLayerManager,\n                agm_core_LayerManager,\n                agm_core_MarkerManager,\n                agm_core_PolygonManager,\n                agm_core_PolylineManager,\n                agm_core_RectangleManager,\n            ]), core[\"Ab\" /* ɵɵNgOnChangesFeature */]], ngContentSelectors: _c0, decls: 3, vars: 0, consts: [[1, \"agm-map-container-inner\", \"sebm-google-map-container-inner\"], [1, \"agm-map-content\"]], template: function AgmMap_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"oc\" /* ɵɵprojectionDef */]();\n                core[\"Rb\" /* ɵɵelement */](0, \"div\", 0);\n                core[\"Wb\" /* ɵɵelementStart */](1, \"div\", 1);\n                core[\"nc\" /* ɵɵprojection */](2);\n                core[\"Vb\" /* ɵɵelementEnd */]();\n            }\n        }, styles: [\".agm-map-container-inner[_ngcontent-%COMP%] {\\n      width: inherit;\\n      height: inherit;\\n    }\\n    .agm-map-content[_ngcontent-%COMP%] {\\n      display:none;\\n    }\"] });\n    /**\n     * Map option attributes that can change over time\n     */\n    AgmMap._mapOptionsAttributes = [\n        'disableDoubleClickZoom', 'scrollwheel', 'draggable', 'draggableCursor', 'draggingCursor',\n        'keyboardShortcuts', 'zoomControl', 'zoomControlOptions', 'styles', 'streetViewControl',\n        'streetViewControlOptions', 'zoom', 'mapTypeControl', 'mapTypeControlOptions', 'minZoom',\n        'maxZoom', 'panControl', 'panControlOptions', 'rotateControl', 'rotateControlOptions',\n        'fullscreenControl', 'fullscreenControlOptions', 'scaleControl', 'scaleControlOptions',\n        'mapTypeId', 'clickableIcons', 'gestureHandling', 'tilt', 'restriction',\n    ];\n    AgmMap = AgmMap_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__param\"])(2, Object(core[\"p\" /* Inject */])(core[\"B\" /* PLATFORM_ID */])),\n        Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [core[\"l\" /* ElementRef */],\n            agm_core_GoogleMapsAPIWrapper,\n            Object,\n            agm_core_FitBoundsService,\n            core[\"z\" /* NgZone */]])\n    ], AgmMap);\n    return AgmMap;\n})();\nvar AgmMarker_1;\nlet markerId = 0;\nlet agm_core_AgmMarker = /*@__PURE__*/ (() => {\n    /**\n     * AgmMarker renders a map marker inside a {@link AgmMap}.\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from '@angular/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  styles: [`\n     *    .agm-map-container {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *      <agm-marker [latitude]=\"lat\" [longitude]=\"lng\" [label]=\"'M'\">\n     *      </agm-marker>\n     *    </agm-map>\n     *  `\n     * })\n     * ```\n     */\n    let AgmMarker = AgmMarker_1 = class AgmMarker {\n        constructor(_markerManager) {\n            this._markerManager = _markerManager;\n            /**\n             * If true, the marker can be dragged. Default value is false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If true, the marker is visible\n             */\n            this.visible = true;\n            /**\n             * Whether to automatically open the child info window when the marker is clicked.\n             */\n            this.openInfoWindow = true;\n            /**\n             * The marker's opacity between 0.0 and 1.0.\n             */\n            this.opacity = 1;\n            /**\n             * All markers are displayed on the map in order of their zIndex, with higher values displaying in\n             * front of markers with lower values. By default, markers are displayed according to their\n             * vertical position on screen, with lower markers appearing in front of markers further up the\n             * screen.\n             */\n            this.zIndex = 1;\n            /**\n             * If true, the marker can be clicked. Default value is true.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.clickable = true;\n            /**\n             * This event is fired when the marker's animation property changes.\n             *\n             * @memberof AgmMarker\n             */\n            this.animationChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks on the marker.\n             */\n            this.markerClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks twice on the marker.\n             */\n            this.markerDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user rightclicks on the marker.\n             */\n            this.markerRightClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user starts dragging the marker.\n             */\n            this.dragStart = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is repeatedly fired while the user drags the marker.\n             */\n            this.drag = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user stops dragging the marker.\n             */\n            this.dragEnd = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user mouses over the marker.\n             */\n            this.mouseOver = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user mouses outside the marker.\n             */\n            this.mouseOut = new core[\"n\" /* EventEmitter */]();\n            /** @internal */\n            this.infoWindow = new core[\"D\" /* QueryList */]();\n            this._markerAddedToManger = false;\n            this._observableSubscriptions = [];\n            this._fitBoundsDetails$ = new ReplaySubject[\"a\" /* ReplaySubject */](1);\n            this._id = (markerId++).toString();\n        }\n        /* @internal */\n        ngAfterContentInit() {\n            this.handleInfoWindowUpdate();\n            this.infoWindow.changes.subscribe(() => this.handleInfoWindowUpdate());\n        }\n        handleInfoWindowUpdate() {\n            if (this.infoWindow.length > 1) {\n                throw new Error('Expected no more than one info window.');\n            }\n            this.infoWindow.forEach(marker => {\n                marker.hostMarker = this;\n            });\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (typeof this.latitude === 'string') {\n                this.latitude = Number(this.latitude);\n            }\n            if (typeof this.longitude === 'string') {\n                this.longitude = Number(this.longitude);\n            }\n            if (typeof this.latitude !== 'number' || typeof this.longitude !== 'number') {\n                return;\n            }\n            if (!this._markerAddedToManger) {\n                this._markerManager.addMarker(this);\n                this._updateFitBoundsDetails();\n                this._markerAddedToManger = true;\n                this._addEventListeners();\n                return;\n            }\n            if (changes['latitude'] || changes['longitude']) {\n                this._markerManager.updateMarkerPosition(this);\n                this._updateFitBoundsDetails();\n            }\n            if (changes['title']) {\n                this._markerManager.updateTitle(this);\n            }\n            if (changes['label']) {\n                this._markerManager.updateLabel(this);\n            }\n            if (changes['draggable']) {\n                this._markerManager.updateDraggable(this);\n            }\n            if (changes['iconUrl']) {\n                this._markerManager.updateIcon(this);\n            }\n            if (changes['opacity']) {\n                this._markerManager.updateOpacity(this);\n            }\n            if (changes['visible']) {\n                this._markerManager.updateVisible(this);\n            }\n            if (changes['zIndex']) {\n                this._markerManager.updateZIndex(this);\n            }\n            if (changes['clickable']) {\n                this._markerManager.updateClickable(this);\n            }\n            if (changes['animation']) {\n                this._markerManager.updateAnimation(this);\n            }\n        }\n        /** @internal */\n        getFitBoundsDetails$() {\n            return this._fitBoundsDetails$.asObservable();\n        }\n        _updateFitBoundsDetails() {\n            this._fitBoundsDetails$.next({ latLng: { lat: this.latitude, lng: this.longitude } });\n        }\n        _addEventListeners() {\n            const cs = this._markerManager.createEventObservable('click', this).subscribe(() => {\n                if (this.openInfoWindow) {\n                    this.infoWindow.forEach(infoWindow => infoWindow.open());\n                }\n                this.markerClick.emit(this);\n            });\n            this._observableSubscriptions.push(cs);\n            const dcs = this._markerManager.createEventObservable('dblclick', this).subscribe(() => {\n                this.markerDblClick.emit(null);\n            });\n            this._observableSubscriptions.push(dcs);\n            const rc = this._markerManager.createEventObservable('rightclick', this).subscribe(() => {\n                this.markerRightClick.emit(null);\n            });\n            this._observableSubscriptions.push(rc);\n            const ds = this._markerManager.createEventObservable('dragstart', this)\n                .subscribe((e) => {\n                this.dragStart.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n            });\n            this._observableSubscriptions.push(ds);\n            const d = this._markerManager.createEventObservable('drag', this)\n                .subscribe((e) => {\n                this.drag.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n            });\n            this._observableSubscriptions.push(d);\n            const de = this._markerManager.createEventObservable('dragend', this)\n                .subscribe((e) => {\n                this.dragEnd.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n            });\n            this._observableSubscriptions.push(de);\n            const mover = this._markerManager.createEventObservable('mouseover', this)\n                .subscribe((e) => {\n                this.mouseOver.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n            });\n            this._observableSubscriptions.push(mover);\n            const mout = this._markerManager.createEventObservable('mouseout', this)\n                .subscribe((e) => {\n                this.mouseOut.emit({ coords: { lat: e.latLng.lat(), lng: e.latLng.lng() } });\n            });\n            this._observableSubscriptions.push(mout);\n            const anChng = this._markerManager.createEventObservable('animation_changed', this)\n                .subscribe(() => {\n                this.animationChange.emit(this.animation);\n            });\n            this._observableSubscriptions.push(anChng);\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return 'AgmMarker-' + this._id.toString(); }\n        /** @internal */\n        ngOnDestroy() {\n            this._markerManager.deleteMarker(this);\n            // unsubscribe all registered observable subscriptions\n            this._observableSubscriptions.forEach((s) => s.unsubscribe());\n        }\n    };\n    AgmMarker.ɵfac = function AgmMarker_Factory(t) { return new (t || AgmMarker)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_MarkerManager)); };\n    AgmMarker.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmMarker, selectors: [[\"agm-marker\"]], contentQueries: function AgmMarker_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, agm_core_AgmInfoWindow, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"Bc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.infoWindow = _t);\n            }\n        }, inputs: { latitude: \"latitude\", longitude: \"longitude\", title: \"title\", label: \"label\", draggable: [\"markerDraggable\", \"draggable\"], iconUrl: \"iconUrl\", openInfoWindow: \"openInfoWindow\", opacity: \"opacity\", visible: \"visible\", zIndex: \"zIndex\", animation: \"animation\", clickable: [\"markerClickable\", \"clickable\"] }, outputs: { markerClick: \"markerClick\", dragStart: \"dragStart\", drag: \"drag\", dragEnd: \"dragEnd\", mouseOver: \"mouseOver\", mouseOut: \"mouseOut\", animationChange: \"animationChange\", markerDblClick: \"markerDblClick\", markerRightClick: \"markerRightClick\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                { provide: FitBoundsAccessor, useExisting: Object(core[\"X\" /* forwardRef */])(() => AgmMarker_1) },\n            ]), core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmMarker = AgmMarker_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_MarkerManager])\n    ], AgmMarker);\n    return AgmMarker;\n})();\nvar AgmPolygon_1;\nlet agm_core_AgmPolygon = /*@__PURE__*/ (() => {\n    /**\n     * AgmPolygon renders a polygon on a {@link AgmMap}\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from '@angular/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  styles: [`\n     *    agm-map {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *      <agm-polygon [paths]=\"paths\">\n     *      </agm-polygon>\n     *    </agm-map>\n     *  `\n     * })\n     * export class MyMapCmp {\n     *   lat: number = 0;\n     *   lng: number = 0;\n     *   zoom: number = 10;\n     *   paths: Array<LatLngLiteral> = [\n     *     { lat: 0,  lng: 10 },\n     *     { lat: 0,  lng: 20 },\n     *     { lat: 10, lng: 20 },\n     *     { lat: 10, lng: 10 },\n     *     { lat: 0,  lng: 10 }\n     *   ]\n     *   // Nesting paths will create a hole where they overlap;\n     *   nestedPaths: Array<Array<LatLngLiteral>> = [[\n     *     { lat: 0,  lng: 10 },\n     *     { lat: 0,  lng: 20 },\n     *     { lat: 10, lng: 20 },\n     *     { lat: 10, lng: 10 },\n     *     { lat: 0,  lng: 10 }\n     *   ], [\n     *     { lat: 0, lng: 15 },\n     *     { lat: 0, lng: 20 },\n     *     { lat: 5, lng: 20 },\n     *     { lat: 5, lng: 15 },\n     *     { lat: 0, lng: 15 }\n     *   ]]\n     * }\n     * ```\n     */\n    let AgmPolygon = AgmPolygon_1 = class AgmPolygon {\n        constructor(_polygonManager) {\n            this._polygonManager = _polygonManager;\n            /**\n             * Indicates whether this Polygon handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this shape over the map. The geodesic\n             * property defines the mode of dragging. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this shape by dragging the control\n             * points shown at the vertices and on each segment. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * When true, edges of the polygon are interpreted as geodesic and will\n             * follow the curvature of the Earth. When false, edges of the polygon are\n             * rendered as straight lines in screen space. Note that the shape of a\n             * geodesic polygon may appear to change when dragged, as the dimensions\n             * are maintained relative to the surface of the earth. Defaults to false.\n             */\n            this.geodesic = false;\n            /**\n             * The ordered sequence of coordinates that designates a closed loop.\n             * Unlike polylines, a polygon may consist of one or more paths.\n             *  As a result, the paths property may specify one or more arrays of\n             * LatLng coordinates. Paths are closed automatically; do not repeat the\n             * first vertex of the path as the last vertex. Simple polygons may be\n             * defined using a single array of LatLngs. More complex polygons may\n             * specify an array of arrays. Any simple arrays are converted into Arrays.\n             * Inserting or removing LatLngs from the Array will automatically update\n             * the polygon on the map.\n             */\n            this.paths = [];\n            /**\n             * This event is fired when the DOM click event is fired on the Polygon.\n             */\n            this.polyClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM dblclick event is fired on the Polygon.\n             */\n            this.polyDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is repeatedly fired while the user drags the polygon.\n             */\n            this.polyDrag = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user stops dragging the polygon.\n             */\n            this.polyDragEnd = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user starts dragging the polygon.\n             */\n            this.polyDragStart = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the Polygon.\n             */\n            this.polyMouseDown = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the Polygon.\n             */\n            this.polyMouseMove = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on Polygon mouseout.\n             */\n            this.polyMouseOut = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on Polygon mouseover.\n             */\n            this.polyMouseOver = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired whe the DOM mouseup event is fired on the Polygon\n             */\n            this.polyMouseUp = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the Polygon is right-clicked on.\n             */\n            this.polyRightClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired after Polygon first path changes.\n             */\n            this.polyPathsChange = new core[\"n\" /* EventEmitter */]();\n            this._polygonAddedToManager = false;\n            this._subscriptions = [];\n        }\n        /** @internal */\n        ngAfterContentInit() {\n            if (!this._polygonAddedToManager) {\n                this._init();\n            }\n        }\n        ngOnChanges(changes) {\n            if (!this._polygonAddedToManager) {\n                this._init();\n                return;\n            }\n            this._polygonManager.setPolygonOptions(this, this._updatePolygonOptions(changes));\n        }\n        _init() {\n            this._polygonManager.addPolygon(this);\n            this._polygonAddedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const handlers = [\n                { name: 'click', handler: (ev) => this.polyClick.emit(ev) },\n                { name: 'dblclick', handler: (ev) => this.polyDblClick.emit(ev) },\n                { name: 'drag', handler: (ev) => this.polyDrag.emit(ev) },\n                { name: 'dragend', handler: (ev) => this.polyDragEnd.emit(ev) },\n                { name: 'dragstart', handler: (ev) => this.polyDragStart.emit(ev) },\n                { name: 'mousedown', handler: (ev) => this.polyMouseDown.emit(ev) },\n                { name: 'mousemove', handler: (ev) => this.polyMouseMove.emit(ev) },\n                { name: 'mouseout', handler: (ev) => this.polyMouseOut.emit(ev) },\n                { name: 'mouseover', handler: (ev) => this.polyMouseOver.emit(ev) },\n                { name: 'mouseup', handler: (ev) => this.polyMouseUp.emit(ev) },\n                { name: 'rightclick', handler: (ev) => this.polyRightClick.emit(ev) },\n            ];\n            handlers.forEach((obj) => {\n                const os = this._polygonManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n            this._polygonManager.createPathEventObservable(this)\n                .then(paths$ => {\n                const os = paths$.subscribe(pathEvent => this.polyPathsChange.emit(pathEvent));\n                this._subscriptions.push(os);\n            });\n        }\n        _updatePolygonOptions(changes) {\n            return Object.keys(changes)\n                .filter(k => AgmPolygon_1._polygonOptionsAttributes.indexOf(k) !== -1)\n                .reduce((obj, k) => {\n                obj[k] = changes[k].currentValue;\n                return obj;\n            }, {});\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        ngOnDestroy() {\n            this._polygonManager.deletePolygon(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach((s) => s.unsubscribe());\n        }\n        getPath() {\n            return this._polygonManager.getPath(this);\n        }\n        getPaths() {\n            return this._polygonManager.getPaths(this);\n        }\n    };\n    AgmPolygon.ɵfac = function AgmPolygon_Factory(t) { return new (t || AgmPolygon)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_PolygonManager)); };\n    AgmPolygon.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmPolygon, selectors: [[\"agm-polygon\"]], inputs: { clickable: \"clickable\", draggable: [\"polyDraggable\", \"draggable\"], editable: \"editable\", geodesic: \"geodesic\", paths: \"paths\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\", visible: \"visible\", zIndex: \"zIndex\" }, outputs: { polyClick: \"polyClick\", polyDblClick: \"polyDblClick\", polyDrag: \"polyDrag\", polyDragEnd: \"polyDragEnd\", polyDragStart: \"polyDragStart\", polyMouseDown: \"polyMouseDown\", polyMouseMove: \"polyMouseMove\", polyMouseOut: \"polyMouseOut\", polyMouseOver: \"polyMouseOver\", polyMouseUp: \"polyMouseUp\", polyRightClick: \"polyRightClick\", polyPathsChange: \"polyPathsChange\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmPolygon._polygonOptionsAttributes = [\n        'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'icon', 'map',\n        'paths', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'draggable',\n        'editable', 'visible',\n    ];\n    AgmPolygon = AgmPolygon_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_PolygonManager])\n    ], AgmPolygon);\n    return AgmPolygon;\n})();\nlet agm_core_AgmPolylineIcon = /*@__PURE__*/ (() => {\n    /**\n     * AgmPolylineIcon enables to add polyline sequences to add arrows, circle,\n     * or custom icons either along the entire line, or in a specific part of it.\n     * See https://developers.google.com/maps/documentation/javascript/shapes#polyline_customize\n     *\n     * ### Example\n     * ```html\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *      <agm-polyline>\n     *          <agm-icon-sequence [fixedRotation]=\"true\" [path]=\"'FORWARD_OPEN_ARROW'\">\n     *          </agm-icon-sequence>\n     *      </agm-polyline>\n     *    </agm-map>\n     * ```\n     *\n     * @export\n     * @class AgmPolylineIcon\n     */\n    let AgmPolylineIcon = class AgmPolylineIcon {\n        ngOnInit() {\n            if (this.path == null) {\n                throw new Error('Icon Sequence path is required');\n            }\n        }\n    };\n    AgmPolylineIcon.ɵfac = function AgmPolylineIcon_Factory(t) { return new (t || AgmPolylineIcon)(); };\n    AgmPolylineIcon.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmPolylineIcon, selectors: [[\"agm-icon-sequence\"]], inputs: { fixedRotation: \"fixedRotation\", offset: \"offset\", repeat: \"repeat\", anchorX: \"anchorX\", anchorY: \"anchorY\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", path: \"path\", rotation: \"rotation\", scale: \"scale\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\" } });\n    return AgmPolylineIcon;\n})();\nvar AgmPolylinePoint_1;\nlet agm_core_AgmPolylinePoint = /*@__PURE__*/ (() => {\n    /**\n     * AgmPolylinePoint represents one element of a polyline within a  {@link\n     * AgmPolyline}\n     */\n    let AgmPolylinePoint = AgmPolylinePoint_1 = class AgmPolylinePoint {\n        constructor() {\n            /**\n             * This event emitter gets emitted when the position of the point changed.\n             */\n            this.positionChanged = new core[\"n\" /* EventEmitter */]();\n        }\n        ngOnChanges(changes) {\n            if (changes['latitude'] || changes['longitude']) {\n                const position = {\n                    lat: changes['latitude'] ? changes['latitude'].currentValue : this.latitude,\n                    lng: changes['longitude'] ? changes['longitude'].currentValue : this.longitude,\n                };\n                this.positionChanged.emit(position);\n            }\n        }\n        /** @internal */\n        getFitBoundsDetails$() {\n            return this.positionChanged.pipe(Object(startWith[\"a\" /* startWith */])({ lat: this.latitude, lng: this.longitude }), Object(map[\"a\" /* map */])(position => ({ latLng: position })));\n        }\n    };\n    AgmPolylinePoint.ɵfac = function AgmPolylinePoint_Factory(t) { return new (t || AgmPolylinePoint)(); };\n    AgmPolylinePoint.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmPolylinePoint, selectors: [[\"agm-polyline-point\"]], inputs: { latitude: \"latitude\", longitude: \"longitude\" }, outputs: { positionChanged: \"positionChanged\" }, features: [core[\"Bb\" /* ɵɵProvidersFeature */]([\n                { provide: FitBoundsAccessor, useExisting: Object(core[\"X\" /* forwardRef */])(() => AgmPolylinePoint_1) },\n            ]), core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmPolylinePoint = AgmPolylinePoint_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [])\n    ], AgmPolylinePoint);\n    return AgmPolylinePoint;\n})();\nvar AgmPolyline_1;\nlet polylineId = 0;\nlet agm_core_AgmPolyline = /*@__PURE__*/ (() => {\n    /**\n     * AgmPolyline renders a polyline on a {@link AgmMap}\n     *\n     * ### Example\n     * ```typescript\n     * import { Component } from '@angular/core';\n     *\n     * @Component({\n     *  selector: 'my-map-cmp',\n     *  styles: [`\n     *    .agm-map-container {\n     *      height: 300px;\n     *    }\n     * `],\n     *  template: `\n     *    <agm-map [latitude]=\"lat\" [longitude]=\"lng\" [zoom]=\"zoom\">\n     *      <agm-polyline>\n     *          <agm-polyline-point [latitude]=\"latA\" [longitude]=\"lngA\">\n     *          </agm-polyline-point>\n     *          <agm-polyline-point [latitude]=\"latB\" [longitude]=\"lngB\">\n     *          </agm-polyline-point>\n     *      </agm-polyline>\n     *    </agm-map>\n     *  `\n     * })\n     * ```\n     */\n    let AgmPolyline = AgmPolyline_1 = class AgmPolyline {\n        constructor(_polylineManager) {\n            this._polylineManager = _polylineManager;\n            /**\n             * Indicates whether this Polyline handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this shape over the map. The geodesic property defines the\n             * mode of dragging. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this shape by dragging the control points shown at the\n             * vertices and on each segment. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * When true, edges of the polygon are interpreted as geodesic and will follow the curvature of\n             * the Earth. When false, edges of the polygon are rendered as straight lines in screen space.\n             * Note that the shape of a geodesic polygon may appear to change when dragged, as the dimensions\n             * are maintained relative to the surface of the earth. Defaults to false.\n             */\n            this.geodesic = false;\n            /**\n             * Whether this polyline is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the DOM click event is fired on the Polyline.\n             */\n            this.lineClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM dblclick event is fired on the Polyline.\n             */\n            this.lineDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is repeatedly fired while the user drags the polyline.\n             */\n            this.lineDrag = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user stops dragging the polyline.\n             */\n            this.lineDragEnd = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user starts dragging the polyline.\n             */\n            this.lineDragStart = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the Polyline.\n             */\n            this.lineMouseDown = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the Polyline.\n             */\n            this.lineMouseMove = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on Polyline mouseout.\n             */\n            this.lineMouseOut = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on Polyline mouseover.\n             */\n            this.lineMouseOver = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired whe the DOM mouseup event is fired on the Polyline\n             */\n            this.lineMouseUp = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the Polyline is right-clicked on.\n             */\n            this.lineRightClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired after Polyline's path changes.\n             */\n            this.polyPathChange = new core[\"n\" /* EventEmitter */]();\n            this._polylineAddedToManager = false;\n            this._subscriptions = [];\n            this._id = (polylineId++).toString();\n        }\n        /** @internal */\n        ngAfterContentInit() {\n            if (this.points.length) {\n                this.points.forEach((point) => {\n                    const s = point.positionChanged.subscribe(() => { this._polylineManager.updatePolylinePoints(this); });\n                    this._subscriptions.push(s);\n                });\n            }\n            if (!this._polylineAddedToManager) {\n                this._init();\n            }\n            const pointSub = this.points.changes.subscribe(() => this._polylineManager.updatePolylinePoints(this));\n            this._subscriptions.push(pointSub);\n            this._polylineManager.updatePolylinePoints(this);\n            const iconSub = this.iconSequences.changes.subscribe(() => this._polylineManager.updateIconSequences(this));\n            this._subscriptions.push(iconSub);\n        }\n        ngOnChanges(changes) {\n            if (!this._polylineAddedToManager) {\n                this._init();\n                return;\n            }\n            let options = {};\n            const optionKeys = Object.keys(changes).filter(k => AgmPolyline_1._polylineOptionsAttributes.indexOf(k) !== -1);\n            optionKeys.forEach(k => options[k] = changes[k].currentValue);\n            this._polylineManager.setPolylineOptions(this, options);\n        }\n        getPath() {\n            return this._polylineManager.getPath(this);\n        }\n        _init() {\n            this._polylineManager.addPolyline(this);\n            this._polylineAddedToManager = true;\n            this._addEventListeners();\n        }\n        _addEventListeners() {\n            const handlers = [\n                { name: 'click', handler: (ev) => this.lineClick.emit(ev) },\n                { name: 'dblclick', handler: (ev) => this.lineDblClick.emit(ev) },\n                { name: 'drag', handler: (ev) => this.lineDrag.emit(ev) },\n                { name: 'dragend', handler: (ev) => this.lineDragEnd.emit(ev) },\n                { name: 'dragstart', handler: (ev) => this.lineDragStart.emit(ev) },\n                { name: 'mousedown', handler: (ev) => this.lineMouseDown.emit(ev) },\n                { name: 'mousemove', handler: (ev) => this.lineMouseMove.emit(ev) },\n                { name: 'mouseout', handler: (ev) => this.lineMouseOut.emit(ev) },\n                { name: 'mouseover', handler: (ev) => this.lineMouseOver.emit(ev) },\n                { name: 'mouseup', handler: (ev) => this.lineMouseUp.emit(ev) },\n                { name: 'rightclick', handler: (ev) => this.lineRightClick.emit(ev) },\n            ];\n            handlers.forEach((obj) => {\n                const os = this._polylineManager.createEventObservable(obj.name, this).subscribe(obj.handler);\n                this._subscriptions.push(os);\n            });\n            this._polylineManager.createPathEventObservable(this).then((ob$) => {\n                const os = ob$.subscribe(pathEvent => this.polyPathChange.emit(pathEvent));\n                this._subscriptions.push(os);\n            });\n        }\n        /** @internal */\n        _getPoints() {\n            if (this.points) {\n                return this.points.toArray();\n            }\n            return [];\n        }\n        _getIcons() {\n            if (this.iconSequences) {\n                return this.iconSequences.toArray();\n            }\n            return [];\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        ngOnDestroy() {\n            this._polylineManager.deletePolyline(this);\n            // unsubscribe all registered observable subscriptions\n            this._subscriptions.forEach((s) => s.unsubscribe());\n        }\n    };\n    AgmPolyline.ɵfac = function AgmPolyline_Factory(t) { return new (t || AgmPolyline)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_PolylineManager)); };\n    AgmPolyline.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmPolyline, selectors: [[\"agm-polyline\"]], contentQueries: function AgmPolyline_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, agm_core_AgmPolylinePoint, false);\n                core[\"Jb\" /* ɵɵcontentQuery */](dirIndex, agm_core_AgmPolylineIcon, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"Bc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.points = _t);\n                core[\"Bc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.iconSequences = _t);\n            }\n        }, inputs: { clickable: \"clickable\", draggable: [\"polylineDraggable\", \"draggable\"], editable: \"editable\", geodesic: \"geodesic\", visible: \"visible\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", strokeWeight: \"strokeWeight\", zIndex: \"zIndex\" }, outputs: { lineClick: \"lineClick\", lineDblClick: \"lineDblClick\", lineDrag: \"lineDrag\", lineDragEnd: \"lineDragEnd\", lineDragStart: \"lineDragStart\", lineMouseDown: \"lineMouseDown\", lineMouseMove: \"lineMouseMove\", lineMouseOut: \"lineMouseOut\", lineMouseOver: \"lineMouseOver\", lineMouseUp: \"lineMouseUp\", lineRightClick: \"lineRightClick\", polyPathChange: \"polyPathChange\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmPolyline._polylineOptionsAttributes = [\n        'draggable', 'editable', 'visible', 'geodesic', 'strokeColor', 'strokeOpacity', 'strokeWeight',\n        'zIndex',\n    ];\n    AgmPolyline = AgmPolyline_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_PolylineManager])\n    ], AgmPolyline);\n    return AgmPolyline;\n})();\nvar AgmRectangle_1;\nlet agm_core_AgmRectangle = /*@__PURE__*/ (() => {\n    let AgmRectangle = AgmRectangle_1 = class AgmRectangle {\n        constructor(_manager) {\n            this._manager = _manager;\n            /**\n             * Indicates whether this Rectangle handles mouse events. Defaults to true.\n             */\n            this.clickable = true;\n            /**\n             * If set to true, the user can drag this rectangle over the map. Defaults to false.\n             */\n            // tslint:disable-next-line:no-input-rename\n            this.draggable = false;\n            /**\n             * If set to true, the user can edit this rectangle by dragging the control points shown at\n             * the center and around the circumference of the rectangle. Defaults to false.\n             */\n            this.editable = false;\n            /**\n             * The stroke position. Defaults to CENTER.\n             * This property is not supported on Internet Explorer 8 and earlier.\n             */\n            this.strokePosition = 'CENTER';\n            /**\n             * The stroke width in pixels.\n             */\n            this.strokeWeight = 0;\n            /**\n             * Whether this rectangle is visible on the map. Defaults to true.\n             */\n            this.visible = true;\n            /**\n             * This event is fired when the rectangle's is changed.\n             */\n            this.boundsChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks on the rectangle.\n             */\n            this.rectangleClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event emitter gets emitted when the user clicks on the rectangle.\n             */\n            this.rectangleDblClick = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is repeatedly fired while the user drags the rectangle.\n             */\n            this.drag = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user stops dragging the rectangle.\n             */\n            this.dragEnd = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the user starts dragging the rectangle.\n             */\n            this.dragStart = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousedown event is fired on the rectangle.\n             */\n            this.mouseDown = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mousemove event is fired on the rectangle.\n             */\n            this.mouseMove = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on rectangle mouseout.\n             */\n            this.mouseOut = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired on rectangle mouseover.\n             */\n            this.mouseOver = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the DOM mouseup event is fired on the rectangle.\n             */\n            this.mouseUp = new core[\"n\" /* EventEmitter */]();\n            /**\n             * This event is fired when the rectangle is right-clicked on.\n             */\n            this.rightClick = new core[\"n\" /* EventEmitter */]();\n            this._rectangleAddedToManager = false;\n            this._eventSubscriptions = [];\n        }\n        /** @internal */\n        ngOnInit() {\n            this._manager.addRectangle(this);\n            this._rectangleAddedToManager = true;\n            this._registerEventListeners();\n        }\n        /** @internal */\n        ngOnChanges(changes) {\n            if (!this._rectangleAddedToManager) {\n                return;\n            }\n            if (changes['north'] ||\n                changes['east'] ||\n                changes['south'] ||\n                changes['west']) {\n                this._manager.setBounds(this);\n            }\n            if (changes['editable']) {\n                this._manager.setEditable(this);\n            }\n            if (changes['draggable']) {\n                this._manager.setDraggable(this);\n            }\n            if (changes['visible']) {\n                this._manager.setVisible(this);\n            }\n            this._updateRectangleOptionsChanges(changes);\n        }\n        _updateRectangleOptionsChanges(changes) {\n            let options = {};\n            let optionKeys = Object.keys(changes).filter(k => AgmRectangle_1._mapOptions.indexOf(k) !== -1);\n            optionKeys.forEach(k => {\n                options[k] = changes[k].currentValue;\n            });\n            if (optionKeys.length > 0) {\n                this._manager.setOptions(this, options);\n            }\n        }\n        _registerEventListeners() {\n            let events = new Map();\n            events.set('bounds_changed', this.boundsChange);\n            events.set('click', this.rectangleClick);\n            events.set('dblclick', this.rectangleDblClick);\n            events.set('drag', this.drag);\n            events.set('dragend', this.dragEnd);\n            events.set('dragStart', this.dragStart);\n            events.set('mousedown', this.mouseDown);\n            events.set('mousemove', this.mouseMove);\n            events.set('mouseout', this.mouseOut);\n            events.set('mouseover', this.mouseOver);\n            events.set('mouseup', this.mouseUp);\n            events.set('rightclick', this.rightClick);\n            events.forEach((eventEmitter, eventName) => {\n                this._eventSubscriptions.push(this._manager\n                    .createEventObservable(eventName, this)\n                    .subscribe(value => {\n                    switch (eventName) {\n                        case 'bounds_changed':\n                            this._manager.getBounds(this).then(bounds => eventEmitter.emit({\n                                north: bounds.getNorthEast().lat(),\n                                east: bounds.getNorthEast().lng(),\n                                south: bounds.getSouthWest().lat(),\n                                west: bounds.getSouthWest().lng(),\n                            }));\n                            break;\n                        default:\n                            eventEmitter.emit({\n                                coords: { lat: value.latLng.lat(), lng: value.latLng.lng() },\n                            });\n                    }\n                }));\n            });\n        }\n        /** @internal */\n        ngOnDestroy() {\n            this._eventSubscriptions.forEach(function (s) {\n                s.unsubscribe();\n            });\n            this._eventSubscriptions = null;\n            this._manager.removeRectangle(this);\n        }\n        /**\n         * Gets the LatLngBounds of this Rectangle.\n         */\n        getBounds() {\n            return this._manager.getBounds(this);\n        }\n    };\n    AgmRectangle.ɵfac = function AgmRectangle_Factory(t) { return new (t || AgmRectangle)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_RectangleManager)); };\n    AgmRectangle.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmRectangle, selectors: [[\"agm-rectangle\"]], inputs: { clickable: \"clickable\", draggable: [\"rectangleDraggable\", \"draggable\"], editable: \"editable\", strokePosition: \"strokePosition\", strokeWeight: \"strokeWeight\", visible: \"visible\", north: \"north\", east: \"east\", south: \"south\", west: \"west\", fillColor: \"fillColor\", fillOpacity: \"fillOpacity\", strokeColor: \"strokeColor\", strokeOpacity: \"strokeOpacity\", zIndex: \"zIndex\" }, outputs: { boundsChange: \"boundsChange\", rectangleClick: \"rectangleClick\", rectangleDblClick: \"rectangleDblClick\", drag: \"drag\", dragEnd: \"dragEnd\", dragStart: \"dragStart\", mouseDown: \"mouseDown\", mouseMove: \"mouseMove\", mouseOut: \"mouseOut\", mouseOver: \"mouseOver\", mouseUp: \"mouseUp\", rightClick: \"rightClick\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmRectangle._mapOptions = [\n        'fillColor',\n        'fillOpacity',\n        'strokeColor',\n        'strokeOpacity',\n        'strokePosition',\n        'strokeWeight',\n        'visible',\n        'zIndex',\n        'clickable',\n    ];\n    AgmRectangle = AgmRectangle_1 = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_RectangleManager])\n    ], AgmRectangle);\n    return AgmRectangle;\n})();\nlet layerId$3 = 0;\nlet agm_core_AgmTransitLayer = /*@__PURE__*/ (() => {\n    /*\n     * This directive adds a transit layer to a google map instance\n     * <agm-transit-layer [visible]=\"true|false\"> <agm-transit-layer>\n     * */\n    let AgmTransitLayer = class AgmTransitLayer {\n        constructor(_manager) {\n            this._manager = _manager;\n            this._addedToManager = false;\n            this._id = (layerId$3++).toString();\n            /**\n             * Hide/show transit layer\n             */\n            this.visible = true;\n        }\n        ngOnInit() {\n            if (this._addedToManager) {\n                return;\n            }\n            this._manager.addTransitLayer(this, { visible: this.visible });\n            this._addedToManager = true;\n        }\n        ngOnChanges(changes) {\n            if (!this._addedToManager) {\n                return;\n            }\n            if (changes['visible'] != null) {\n                this._manager.toggleLayerVisibility(this, { visible: changes['visible'].currentValue });\n            }\n        }\n        /** @internal */\n        id() { return this._id; }\n        /** @internal */\n        toString() { return `AgmTransitLayer-${this._id.toString()}`; }\n        /** @internal */\n        ngOnDestroy() {\n            this._manager.deleteLayer(this);\n        }\n    };\n    AgmTransitLayer.ɵfac = function AgmTransitLayer_Factory(t) { return new (t || AgmTransitLayer)(core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_LayerManager)); };\n    AgmTransitLayer.ɵdir = core[\"Lb\" /* ɵɵdefineDirective */]({ type: AgmTransitLayer, selectors: [[\"agm-transit-layer\"]], inputs: { visible: \"visible\" }, features: [core[\"Ab\" /* ɵɵNgOnChangesFeature */]] });\n    AgmTransitLayer = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_LayerManager])\n    ], AgmTransitLayer);\n    return AgmTransitLayer;\n})();\nvar google$1;\nvar SymbolPath = /*@__PURE__*/ (function (SymbolPath) {\n    SymbolPath[SymbolPath[\"BACKWARD_CLOSED_ARROW\"] = 3] = \"BACKWARD_CLOSED_ARROW\";\n    SymbolPath[SymbolPath[\"BACKWARD_OPEN_ARROW\"] = 4] = \"BACKWARD_OPEN_ARROW\";\n    SymbolPath[SymbolPath[\"CIRCLE\"] = 0] = \"CIRCLE\";\n    SymbolPath[SymbolPath[\"FORWARD_CLOSED_ARROW\"] = 1] = \"FORWARD_CLOSED_ARROW\";\n    SymbolPath[SymbolPath[\"FORWARD_OPEN_ARROW\"] = 2] = \"FORWARD_OPEN_ARROW\";\n    return SymbolPath;\n})({});\n/**\n * Identifiers used to specify the placement of controls on the map. Controls are\n * positioned relative to other controls in the same layout position. Controls that\n * are added first are positioned closer to the edge of the map.\n */\nvar ControlPosition = /*@__PURE__*/ (function (ControlPosition) {\n    ControlPosition[ControlPosition[\"RIGHT_BOTTOM\"] = 0] = \"RIGHT_BOTTOM\";\n    ControlPosition[ControlPosition[\"TOP_LEFT\"] = 1] = \"TOP_LEFT\";\n    ControlPosition[ControlPosition[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n    ControlPosition[ControlPosition[\"TOP_RIGHT\"] = 3] = \"TOP_RIGHT\";\n    ControlPosition[ControlPosition[\"LEFT_CENTER\"] = 4] = \"LEFT_CENTER\";\n    ControlPosition[ControlPosition[\"LEFT_TOP\"] = 5] = \"LEFT_TOP\";\n    ControlPosition[ControlPosition[\"LEFT_BOTTOM\"] = 6] = \"LEFT_BOTTOM\";\n    ControlPosition[ControlPosition[\"RIGHT_TOP\"] = 7] = \"RIGHT_TOP\";\n    ControlPosition[ControlPosition[\"RIGHT_CENTER\"] = 8] = \"RIGHT_CENTER\";\n    ControlPosition[ControlPosition[\"BOTTOM_RIGHT\"] = 9] = \"BOTTOM_RIGHT\";\n    ControlPosition[ControlPosition[\"BOTTOM_LEFT\"] = 10] = \"BOTTOM_LEFT\";\n    ControlPosition[ControlPosition[\"BOTTOM_CENTER\"] = 11] = \"BOTTOM_CENTER\";\n    return ControlPosition;\n})({});\nvar MapTypeId = /*@__PURE__*/ (function (MapTypeId) {\n    /** This map type displays a transparent layer of major streets on satellite images. */\n    MapTypeId[MapTypeId[\"HYBRID\"] = 0] = \"HYBRID\";\n    /** This map type displays a normal street map. */\n    MapTypeId[MapTypeId[\"ROADMAP\"] = 1] = \"ROADMAP\";\n    /** This map type displays satellite images. */\n    MapTypeId[MapTypeId[\"SATELLITE\"] = 2] = \"SATELLITE\";\n    /** This map type displays maps with physical features such as terrain and vegetation. */\n    MapTypeId[MapTypeId[\"TERRAIN\"] = 3] = \"TERRAIN\";\n    return MapTypeId;\n})({});\nvar MapTypeControlStyle = /*@__PURE__*/ (function (MapTypeControlStyle) {\n    MapTypeControlStyle[MapTypeControlStyle[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    MapTypeControlStyle[MapTypeControlStyle[\"DROPDOWN_MENU\"] = 2] = \"DROPDOWN_MENU\";\n    MapTypeControlStyle[MapTypeControlStyle[\"HORIZONTAL_BAR\"] = 1] = \"HORIZONTAL_BAR\";\n    return MapTypeControlStyle;\n})({});\nvar ScaleControlStyle = /*@__PURE__*/ (function (ScaleControlStyle) {\n    ScaleControlStyle[ScaleControlStyle[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    return ScaleControlStyle;\n})({});\nvar ZoomControlStyle = /*@__PURE__*/ (function (ZoomControlStyle) {\n    ZoomControlStyle[ZoomControlStyle[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ZoomControlStyle[ZoomControlStyle[\"LARGE\"] = 1] = \"LARGE\";\n    ZoomControlStyle[ZoomControlStyle[\"SMALL\"] = 2] = \"SMALL\";\n    return ZoomControlStyle;\n})({});\nvar GeocoderLocationType = /*@__PURE__*/ (function (GeocoderLocationType) {\n    GeocoderLocationType[\"APPROXIMATE\"] = \"APPROXIMATE\";\n    GeocoderLocationType[\"GEOMETRIC_CENTER\"] = \"GEOMETRIC_CENTER\";\n    GeocoderLocationType[\"RANGE_INTERPOLATED\"] = \"RANGE_INTERPOLATED\";\n    GeocoderLocationType[\"ROOFTOP\"] = \"ROOFTOP\";\n    return GeocoderLocationType;\n})({});\nvar GeocoderStatus = /*@__PURE__*/ (function (GeocoderStatus) {\n    GeocoderStatus[\"ERROR\"] = \"ERROR\";\n    GeocoderStatus[\"INVALID_REQUEST\"] = \"INVALID_REQUEST\";\n    GeocoderStatus[\"OK\"] = \"OK\";\n    GeocoderStatus[\"OVER_QUERY_LIMIT\"] = \"OVER_QUERY_LIMIT\";\n    GeocoderStatus[\"REQUEST_DENIED\"] = \"REQUEST_DENIED\";\n    GeocoderStatus[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    GeocoderStatus[\"ZERO_RESULTS\"] = \"ZERO_RESULTS\";\n    return GeocoderStatus;\n})({});\nlet agm_core_AgmGeocoder = /*@__PURE__*/ (() => {\n    let AgmGeocoder = class AgmGeocoder {\n        constructor(loader) {\n            const connectableGeocoder$ = new Observable[\"a\" /* Observable */](subscriber => {\n                loader.load().then(() => subscriber.next());\n            })\n                .pipe(Object(map[\"a\" /* map */])(() => this._createGeocoder()), Object(multicast[\"a\" /* multicast */])(new ReplaySubject[\"a\" /* ReplaySubject */](1)));\n            connectableGeocoder$.connect(); // ignore the subscription\n            // since we will remain subscribed till application exits\n            this.geocoder$ = connectableGeocoder$;\n        }\n        geocode(request) {\n            return this.geocoder$.pipe(Object(switchMap[\"a\" /* switchMap */])((geocoder) => this._getGoogleResults(geocoder, request)));\n        }\n        _getGoogleResults(geocoder, request) {\n            const geocodeObservable = bindCallback(geocoder.geocode);\n            return geocodeObservable(request).pipe(Object(switchMap[\"a\" /* switchMap */])(([results, status]) => {\n                if (status === GeocoderStatus.OK) {\n                    return Object(of[\"a\" /* of */])(results);\n                }\n                return Object(throwError[\"a\" /* throwError */])(status);\n            }));\n        }\n        _createGeocoder() {\n            return new google.maps.Geocoder();\n        }\n    };\n    AgmGeocoder.ɵfac = function AgmGeocoder_Factory(t) { return new (t || AgmGeocoder)(core[\"dc\" /* ɵɵinject */](agm_core_MapsAPILoader)); };\n    AgmGeocoder.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: AgmGeocoder, factory: function (t) { return AgmGeocoder.ɵfac(t); }, providedIn: 'root' });\n    AgmGeocoder.ngInjectableDef = Object(core[\"Mb\" /* ɵɵdefineInjectable */])({ factory: function AgmGeocoder_Factory() { return new AgmGeocoder(Object(core[\"dc\" /* ɵɵinject */])(agm_core_MapsAPILoader)); }, token: AgmGeocoder, providedIn: \"root\" });\n    AgmGeocoder = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [agm_core_MapsAPILoader])\n    ], AgmGeocoder);\n    return AgmGeocoder;\n})();\nclass WindowRef {\n    getNativeWindow() { return window; }\n}\nclass DocumentRef {\n    getNativeDocument() { return document; }\n}\nconst BROWSER_GLOBALS_PROVIDERS = [WindowRef, DocumentRef];\nvar GoogleMapsScriptProtocol = /*@__PURE__*/ (function (GoogleMapsScriptProtocol) {\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTP\"] = 1] = \"HTTP\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"HTTPS\"] = 2] = \"HTTPS\";\n    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol[\"AUTO\"] = 3] = \"AUTO\";\n    return GoogleMapsScriptProtocol;\n})({});\n/**\n * Token for the config of the LazyMapsAPILoader. Please provide an object of type {@link\n * LazyMapsAPILoaderConfig}.\n */\nconst LAZY_MAPS_API_CONFIG = new core[\"q\" /* InjectionToken */]('angular-google-maps LAZY_MAPS_API_CONFIG');\nlet agm_core_LazyMapsAPILoader = /*@__PURE__*/ (() => {\n    let LazyMapsAPILoader = class LazyMapsAPILoader extends agm_core_MapsAPILoader {\n        constructor(config = null, w, d, localeId) {\n            super();\n            this.localeId = localeId;\n            this._SCRIPT_ID = 'agmGoogleMapsApiScript';\n            this.callbackName = `agmLazyMapsAPILoader`;\n            this._config = config || {};\n            this._windowRef = w;\n            this._documentRef = d;\n        }\n        load() {\n            const window = this._windowRef.getNativeWindow();\n            if (window.google && window.google.maps) {\n                // Google maps already loaded on the page.\n                return Promise.resolve();\n            }\n            if (this._scriptLoadingPromise) {\n                return this._scriptLoadingPromise;\n            }\n            // this can happen in HMR situations or Stackblitz.io editors.\n            const scriptOnPage = this._documentRef.getNativeDocument().getElementById(this._SCRIPT_ID);\n            if (scriptOnPage) {\n                this._assignScriptLoadingPromise(scriptOnPage);\n                return this._scriptLoadingPromise;\n            }\n            const script = this._documentRef.getNativeDocument().createElement('script');\n            script.type = 'text/javascript';\n            script.async = true;\n            script.defer = true;\n            script.id = this._SCRIPT_ID;\n            script.src = this._getScriptSrc(this.callbackName);\n            this._assignScriptLoadingPromise(script);\n            this._documentRef.getNativeDocument().body.appendChild(script);\n            return this._scriptLoadingPromise;\n        }\n        _assignScriptLoadingPromise(scriptElem) {\n            this._scriptLoadingPromise = new Promise((resolve, reject) => {\n                this._windowRef.getNativeWindow()[this.callbackName] = () => {\n                    resolve();\n                };\n                scriptElem.onerror = (error) => {\n                    reject(error);\n                };\n            });\n        }\n        _getScriptSrc(callbackName) {\n            let protocolType = (this._config && this._config.protocol) || GoogleMapsScriptProtocol.HTTPS;\n            let protocol;\n            switch (protocolType) {\n                case GoogleMapsScriptProtocol.AUTO:\n                    protocol = '';\n                    break;\n                case GoogleMapsScriptProtocol.HTTP:\n                    protocol = 'http:';\n                    break;\n                case GoogleMapsScriptProtocol.HTTPS:\n                    protocol = 'https:';\n                    break;\n            }\n            const hostAndPath = this._config.hostAndPath || 'maps.googleapis.com/maps/api/js';\n            const queryParams = {\n                v: this._config.apiVersion || 'quarterly',\n                callback: callbackName,\n                key: this._config.apiKey,\n                client: this._config.clientId,\n                channel: this._config.channel,\n                libraries: this._config.libraries,\n                region: this._config.region,\n                language: this._config.language || this.localeId !== 'en-US' ? this.localeId : null,\n            };\n            const params = Object.keys(queryParams)\n                .filter((k) => queryParams[k] != null)\n                .filter((k) => {\n                // remove empty arrays\n                return !Array.isArray(queryParams[k]) ||\n                    (Array.isArray(queryParams[k]) && queryParams[k].length > 0);\n            })\n                .map((k) => {\n                // join arrays as comma seperated strings\n                let i = queryParams[k];\n                if (Array.isArray(i)) {\n                    return { key: k, value: i.join(',') };\n                }\n                return { key: k, value: queryParams[k] };\n            })\n                .map((entry) => {\n                return `${entry.key}=${entry.value}`;\n            })\n                .join('&');\n            return `${protocol}//${hostAndPath}?${params}`;\n        }\n    };\n    LazyMapsAPILoader.ɵfac = function LazyMapsAPILoader_Factory(t) { return new (t || LazyMapsAPILoader)(core[\"dc\" /* ɵɵinject */](LAZY_MAPS_API_CONFIG, 8), core[\"dc\" /* ɵɵinject */](WindowRef), core[\"dc\" /* ɵɵinject */](DocumentRef), core[\"dc\" /* ɵɵinject */](core[\"u\" /* LOCALE_ID */])); };\n    LazyMapsAPILoader.ɵprov = core[\"Mb\" /* ɵɵdefineInjectable */]({ token: LazyMapsAPILoader, factory: function (t) { return LazyMapsAPILoader.ɵfac(t); } });\n    LazyMapsAPILoader = Object(tslib_es6[\"__decorate\"])([Object(tslib_es6[\"__param\"])(0, Object(core[\"A\" /* Optional */])()), Object(tslib_es6[\"__param\"])(0, Object(core[\"p\" /* Inject */])(LAZY_MAPS_API_CONFIG)),\n        Object(tslib_es6[\"__param\"])(3, Object(core[\"p\" /* Inject */])(core[\"u\" /* LOCALE_ID */])),\n        Object(tslib_es6[\"__metadata\"])(\"design:paramtypes\", [Object, WindowRef, DocumentRef, String])\n    ], LazyMapsAPILoader);\n    return LazyMapsAPILoader;\n})();\n/**\n * When using the NoOpMapsAPILoader, the Google Maps API must be added to the page via a `<script>`\n * Tag.\n * It's important that the Google Maps API script gets loaded first on the page.\n */\nclass NoOpMapsAPILoader {\n    load() {\n        if (!window.google || !window.google.maps) {\n            throw new Error('Google Maps API not loaded on page. Make sure window.google.maps is available!');\n        }\n        return Promise.resolve();\n    }\n}\n// exported map types\nvar AgmCoreModule_1;\n/**\n * @internal\n */\nfunction coreDirectives() {\n    return [\n        agm_core_AgmBicyclingLayer,\n        agm_core_AgmCircle,\n        agm_core_AgmDataLayer,\n        agm_core_AgmFitBounds,\n        agm_core_AgmInfoWindow,\n        agm_core_AgmKmlLayer,\n        agm_core_AgmMap,\n        agm_core_AgmMarker,\n        agm_core_AgmPolygon,\n        agm_core_AgmPolyline,\n        agm_core_AgmPolylineIcon,\n        agm_core_AgmPolylinePoint,\n        agm_core_AgmRectangle,\n        agm_core_AgmTransitLayer,\n    ];\n}\nlet agm_core_AgmCoreModule = /*@__PURE__*/ (() => {\n    /**\n     * The angular-google-maps core module. Contains all Directives/Services/Pipes\n     * of the core module. Please use `AgmCoreModule.forRoot()` in your app module.\n     */\n    let AgmCoreModule = AgmCoreModule_1 = class AgmCoreModule {\n        /**\n         * Please use this method when you register the module at the root level.\n         */\n        static forRoot(lazyMapsAPILoaderConfig) {\n            return {\n                ngModule: AgmCoreModule_1,\n                providers: [\n                    ...BROWSER_GLOBALS_PROVIDERS, { provide: agm_core_MapsAPILoader, useClass: agm_core_LazyMapsAPILoader },\n                    { provide: LAZY_MAPS_API_CONFIG, useValue: lazyMapsAPILoaderConfig },\n                ],\n            };\n        }\n    };\n    AgmCoreModule.ɵmod = core[\"Ob\" /* ɵɵdefineNgModule */]({ type: AgmCoreModule });\n    AgmCoreModule.ɵinj = core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function AgmCoreModule_Factory(t) { return new (t || AgmCoreModule)(); } });\n    return AgmCoreModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"Ic\" /* ɵɵsetNgModuleScope */](agm_core_AgmCoreModule, { declarations: [agm_core_AgmBicyclingLayer, agm_core_AgmCircle, agm_core_AgmDataLayer, agm_core_AgmFitBounds, agm_core_AgmInfoWindow, agm_core_AgmKmlLayer, agm_core_AgmMap, agm_core_AgmMarker, agm_core_AgmPolygon, agm_core_AgmPolyline, agm_core_AgmPolylineIcon, agm_core_AgmPolylinePoint, agm_core_AgmRectangle, agm_core_AgmTransitLayer], exports: [agm_core_AgmBicyclingLayer, agm_core_AgmCircle, agm_core_AgmDataLayer, agm_core_AgmFitBounds, agm_core_AgmInfoWindow, agm_core_AgmKmlLayer, agm_core_AgmMap, agm_core_AgmMarker, agm_core_AgmPolygon, agm_core_AgmPolyline, agm_core_AgmPolylineIcon, agm_core_AgmPolylinePoint, agm_core_AgmRectangle, agm_core_AgmTransitLayer] }); })();\n// main modules\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=agm-core.js.map\n\n// EXTERNAL MODULE: ./src/app/shared/ui/ui.module.ts\nvar ui_module = __webpack_require__(\"4zvT\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js + 3 modules\nvar router = __webpack_require__(\"tyNb\");\n\n// EXTERNAL MODULE: ./src/app/shared/ui/pagetitle/pagetitle.component.ts\nvar pagetitle_component = __webpack_require__(\"V5ls\");\n\n// CONCATENATED MODULE: ./src/app/pages/maps/google/google.component.ts\n\r\n\r\n\r\n\r\n\r\n\r\nconst google_component_c0 = [\"streetviewMap\"];\r\nconst _c1 = [\"streetviewPano\"];\r\nfunction GoogleComponent_agm_marker_19_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Rb\" /* ɵɵelement */](0, \"agm-marker\", 18);\r\n    }\r\n    if (rf & 2) {\r\n        const marker_r3 = ctx.$implicit;\r\n        core[\"pc\" /* ɵɵproperty */](\"latitude\", marker_r3.latitude)(\"longitude\", marker_r3.longitude);\r\n    }\r\n}\r\n/**\r\n * Google component\r\n */\r\nlet google_component_GoogleComponent = /*@__PURE__*/ (() => {\r\n    class GoogleComponent {\r\n        constructor(platformId, mapsAPILoader) {\r\n            this.platformId = platformId;\r\n            this.mapsAPILoader = mapsAPILoader;\r\n            this.longitude = 20.728218;\r\n            this.latitude = 52.128973;\r\n        }\r\n        ngOnInit() {\r\n            this.breadCrumbItems = [{ label: 'Maps' }, { label: 'Google Maps', active: true }];\r\n            this._initPanorama();\r\n            /**\r\n             * fetches data\r\n             */\r\n            this._fetchData();\r\n        }\r\n        /**\r\n         * street view map\r\n         */\r\n        _initPanorama() {\r\n            if (Object(common[\"z\" /* isPlatformBrowser */])(this.platformId)) {\r\n                this.mapsAPILoader.load().then(() => {\r\n                    const center = { lat: 42.345573, lng: -71.098326 };\r\n                    // tslint:disable-next-line: no-string-literal\r\n                    const map = new window['google'].maps.Map(this.streetviewMap.nativeElement, { center, zoom: 12, scrollwheel: false });\r\n                    // tslint:disable-next-line: no-string-literal\r\n                    const panorama = new window['google'].maps.StreetViewPanorama(this.streetviewPano.nativeElement, {\r\n                        position: center,\r\n                        pov: { heading: 34, pitch: 10 },\r\n                        scrollwheel: false\r\n                    });\r\n                    map.setStreetView(panorama);\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         *\r\n         * @param position position where marker added\r\n         */\r\n        placeMarker(position) {\r\n            const lat = position.coords.lat;\r\n            const lng = position.coords.lng;\r\n            this.markers.push({ latitude: lat, longitude: lng });\r\n        }\r\n        /**\r\n         * Fetches the value of map\r\n         */\r\n        _fetchData() {\r\n            this.markers = [\r\n                { latitude: 52.228973, longitude: 20.728218 }\r\n            ];\r\n        }\r\n    }\r\n    GoogleComponent.ɵfac = function GoogleComponent_Factory(t) { return new (t || GoogleComponent)(core[\"Qb\" /* ɵɵdirectiveInject */](core[\"B\" /* PLATFORM_ID */]), core[\"Qb\" /* ɵɵdirectiveInject */](agm_core_MapsAPILoader)); };\r\n    GoogleComponent.ɵcmp = core[\"Kb\" /* ɵɵdefineComponent */]({ type: GoogleComponent, selectors: [[\"app-google\"]], viewQuery: function GoogleComponent_Query(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Kc\" /* ɵɵstaticViewQuery */](google_component_c0, true);\r\n                core[\"Kc\" /* ɵɵstaticViewQuery */](_c1, true);\r\n            }\r\n            if (rf & 2) {\r\n                let _t;\r\n                core[\"Bc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.streetviewMap = _t.first);\r\n                core[\"Bc\" /* ɵɵqueryRefresh */](_t = core[\"hc\" /* ɵɵloadQuery */]()) && (ctx.streetviewPano = _t.first);\r\n            }\r\n        }, decls: 42, vars: 14, consts: [[1, \"container-fluid\"], [\"title\", \"Google Maps\", 3, \"breadcrumbItems\"], [1, \"row\"], [1, \"col-lg-6\"], [1, \"card\"], [1, \"card-body\"], [1, \"card-title\", \"mb-3\"], [1, \"card-title-dsec\"], [2, \"height\", \"300px\", 3, \"latitude\", \"longitude\"], [2, \"height\", \"300px\", 3, \"latitude\", \"longitude\", \"mapClick\"], [3, \"latitude\", \"longitude\", 4, \"ngFor\", \"ngForOf\"], [1, \"mb-3\", \"card-title\"], [\"id\", \"streetview-container\"], [\"id\", \"streetview-map\"], [\"streetviewMap\", \"\"], [\"id\", \"streetview-pano\", 2, \"height\", \"300px\"], [\"streetviewPano\", \"\"], [3, \"latitude\", \"longitude\", \"radius\", \"fillColor\", \"circleDraggable\", \"editable\"], [3, \"latitude\", \"longitude\"]], template: function GoogleComponent_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Wb\" /* ɵɵelementStart */](0, \"div\", 0);\r\n                core[\"Rb\" /* ɵɵelement */](1, \"app-page-title\", 1);\r\n                core[\"Wb\" /* ɵɵelementStart */](2, \"div\", 2);\r\n                core[\"Wb\" /* ɵɵelementStart */](3, \"div\", 3);\r\n                core[\"Wb\" /* ɵɵelementStart */](4, \"div\", 4);\r\n                core[\"Wb\" /* ɵɵelementStart */](5, \"div\", 5);\r\n                core[\"Wb\" /* ɵɵelementStart */](6, \"h4\", 6);\r\n                core[\"Oc\" /* ɵɵtext */](7, \"Basic\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](8, \"p\", 7);\r\n                core[\"Oc\" /* ɵɵtext */](9, \"Example of google maps.\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Rb\" /* ɵɵelement */](10, \"agm-map\", 8);\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](11, \"div\", 3);\r\n                core[\"Wb\" /* ɵɵelementStart */](12, \"div\", 4);\r\n                core[\"Wb\" /* ɵɵelementStart */](13, \"div\", 5);\r\n                core[\"Wb\" /* ɵɵelementStart */](14, \"h4\", 6);\r\n                core[\"Oc\" /* ɵɵtext */](15, \"Markers\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](16, \"p\", 7);\r\n                core[\"Oc\" /* ɵɵtext */](17, \"Example of google maps.\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](18, \"agm-map\", 9);\r\n                core[\"gc\" /* ɵɵlistener */](\"mapClick\", function GoogleComponent_Template_agm_map_mapClick_18_listener($event) { return ctx.placeMarker($event); });\r\n                core[\"Mc\" /* ɵɵtemplate */](19, GoogleComponent_agm_marker_19_Template, 1, 2, \"agm-marker\", 10);\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](20, \"div\", 2);\r\n                core[\"Wb\" /* ɵɵelementStart */](21, \"div\", 3);\r\n                core[\"Wb\" /* ɵɵelementStart */](22, \"div\", 4);\r\n                core[\"Wb\" /* ɵɵelementStart */](23, \"div\", 5);\r\n                core[\"Wb\" /* ɵɵelementStart */](24, \"h4\", 11);\r\n                core[\"Oc\" /* ɵɵtext */](25, \"Street View Panoramas\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](26, \"p\", 7);\r\n                core[\"Oc\" /* ɵɵtext */](27, \"Example of google maps.\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](28, \"div\", 12);\r\n                core[\"Rb\" /* ɵɵelement */](29, \"div\", 13, 14);\r\n                core[\"Rb\" /* ɵɵelement */](31, \"div\", 15, 16);\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](33, \"div\", 3);\r\n                core[\"Wb\" /* ɵɵelementStart */](34, \"div\", 4);\r\n                core[\"Wb\" /* ɵɵelementStart */](35, \"div\", 5);\r\n                core[\"Wb\" /* ɵɵelementStart */](36, \"h4\", 11);\r\n                core[\"Oc\" /* ɵɵtext */](37, \"Location\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](38, \"p\", 7);\r\n                core[\"Oc\" /* ɵɵtext */](39, \"Example of google maps.\");\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Wb\" /* ɵɵelementStart */](40, \"agm-map\", 8);\r\n                core[\"Rb\" /* ɵɵelement */](41, \"agm-circle\", 17);\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n                core[\"Vb\" /* ɵɵelementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                core[\"Cb\" /* ɵɵadvance */](1);\r\n                core[\"pc\" /* ɵɵproperty */](\"breadcrumbItems\", ctx.breadCrumbItems);\r\n                core[\"Cb\" /* ɵɵadvance */](9);\r\n                core[\"pc\" /* ɵɵproperty */](\"latitude\", ctx.latitude)(\"longitude\", ctx.longitude);\r\n                core[\"Cb\" /* ɵɵadvance */](8);\r\n                core[\"pc\" /* ɵɵproperty */](\"latitude\", ctx.latitude)(\"longitude\", ctx.longitude);\r\n                core[\"Cb\" /* ɵɵadvance */](1);\r\n                core[\"pc\" /* ɵɵproperty */](\"ngForOf\", ctx.markers);\r\n                core[\"Cb\" /* ɵɵadvance */](21);\r\n                core[\"pc\" /* ɵɵproperty */](\"latitude\", ctx.latitude)(\"longitude\", ctx.longitude);\r\n                core[\"Cb\" /* ɵɵadvance */](1);\r\n                core[\"pc\" /* ɵɵproperty */](\"latitude\", ctx.latitude)(\"longitude\", ctx.longitude)(\"radius\", 9000)(\"fillColor\", \"red\")(\"circleDraggable\", true)(\"editable\", true);\r\n            }\r\n        }, directives: [pagetitle_component[\"a\" /* PagetitleComponent */], agm_core_AgmMap, common[\"l\" /* NgForOf */], agm_core_AgmCircle, agm_core_AgmMarker], styles: [\"\"] });\r\n    return GoogleComponent;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/app/pages/maps/maps-routing.module.ts\n\r\n\r\n\r\n\r\nconst routes = [\r\n    {\r\n        path: 'google',\r\n        component: google_component_GoogleComponent\r\n    },\r\n];\r\nlet maps_routing_module_MapsRoutingModule = /*@__PURE__*/ (() => {\r\n    class MapsRoutingModule {\r\n    }\r\n    MapsRoutingModule.ɵmod = core[\"Ob\" /* ɵɵdefineNgModule */]({ type: MapsRoutingModule });\r\n    MapsRoutingModule.ɵinj = core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function MapsRoutingModule_Factory(t) { return new (t || MapsRoutingModule)(); }, imports: [[router[\"f\" /* RouterModule */].forChild(routes)], router[\"f\" /* RouterModule */]] });\r\n    return MapsRoutingModule;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/app/pages/maps/maps.module.ts\n\r\n\r\n\r\n\r\n\r\n\r\nlet maps_module_MapsModule = /*@__PURE__*/ (() => {\r\n    class MapsModule {\r\n    }\r\n    MapsModule.ɵmod = core[\"Ob\" /* ɵɵdefineNgModule */]({ type: MapsModule });\r\n    MapsModule.ɵinj = core[\"Nb\" /* ɵɵdefineInjector */]({ factory: function MapsModule_Factory(t) { return new (t || MapsModule)(); }, imports: [[\r\n                common[\"c\" /* CommonModule */],\r\n                maps_routing_module_MapsRoutingModule,\r\n                ui_module[\"a\" /* UIModule */],\r\n                agm_core_AgmCoreModule.forRoot({\r\n                    apiKey: 'AIzaSyAbvyBxmMbFhrzP9Z8moyYr6dCr-pzjhBE'\r\n                }),\r\n            ]] });\r\n    return MapsModule;\r\n})();\r\n\n\n/***/ })\n\n}]);","inputSourceMap":null}